/**
 * @fileoverview Tests for VFS (Virtual Filesystem) support with TAR/TAR.GZ archives.
 *
 * Tests:
 * - VFS initialization and process.binding('smol_vfs')
 * - TAR archive parsing (USTAR, PAX, GNU)
 * - GZIP decompression
 * - SEA + VFS dual resource injection
 * - File extraction to ~/.socket/_dlx/<hash>/
 * - fs module integration
 *
 * Note: These tests require a built smol binary at build/{dev,prod}/out/Final/node/.
 * Run `pnpm build --dev` first to create the binary.
 */

import { existsSync, promises as fs } from 'node:fs'
import { tmpdir } from 'node:os'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import { describe, expect, it, beforeAll, afterAll } from 'vitest'

import { safeDelete, safeMkdir } from '@socketsecurity/lib/fs'
import { spawn } from '@socketsecurity/lib/spawn'

import { MACHO_SEGMENT_NODE_SEA } from '../../../bin-infra/test/helpers/segment-names.mjs'
import { runBinject, SMOL_VFS_BLOB } from '../helpers/binject.mjs'
import { getLatestFinalBinary } from '../paths.mjs'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Get the latest Final binary from build/{dev,prod}/out/Final/node/
// This is the production binary suitable for injection and execution
const finalBinaryPath = getLatestFinalBinary()

// Skip all tests if no final binary is available
const skipTests = !finalBinaryPath || !existsSync(finalBinaryPath)

// Test tmp directory
const testTmpDir = path.join(tmpdir(), 'socket-btm-vfs-tests')

// Use sequential execution to avoid any remaining resource contention
describe.sequential.skipIf(skipTests)(
  'VFS (Virtual Filesystem) support',
  () => {
    const createdCacheDirs = []

    beforeAll(async () => {
      await safeMkdir(testTmpDir)
    })

    afterAll(async () => {
      await safeDelete(testTmpDir)

      // Cleanup all VFS cache directories created during tests
      const cleanupPromises = []
      for (const cacheDir of createdCacheDirs) {
        if (existsSync(cacheDir)) {
          cleanupPromises.push(safeDelete(cacheDir))
        }
      }
      await Promise.allSettled(cleanupPromises)
    })

    describe('SEA fuse injection', () => {
      it('should support NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2 sentinel', async () => {
        const testDir = path.join(testTmpDir, 'sea-fuse')
        await safeMkdir(testDir)

        // Create test app
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(appJs, `console.log('SEA fuse works');`)

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // Generate blob
        // SEA blob will be generated by binject from sea-config.json

        // Copy binary
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        // Inject with correct fuse (binject generates blob from config)
        const injectResult = await runBinject(
          seaBinary,
          'NODE_SEA_BLOB',
          'sea-config.json',
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(injectResult.code).toBe(0)

        // Test execution
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('SEA fuse works')
      })
    })

    describe('VFS TAR archive creation', () => {
      it('should create uncompressed TAR archive', async () => {
        const testDir = path.join(testTmpDir, 'tar-uncompressed')
        await safeMkdir(testDir)

        // Create test files
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'hello.txt'), 'Hello VFS')
        await fs.writeFile(path.join(vfsDir, 'data.json'), '{"test":true}')

        // Create subdirectory
        await safeMkdir(path.join(vfsDir, 'subdir'))
        await fs.writeFile(path.join(vfsDir, 'subdir', 'nested.txt'), 'Nested')

        // Create TAR
        const tarPath = path.join(testDir, 'vfs.tar')
        const tarResult = await spawn(
          'tar',
          ['cf', tarPath, '-C', vfsDir, '.'],
          {
            cwd: testDir,
          },
        )
        expect(tarResult.code).toBe(0)
        expect(existsSync(tarPath)).toBe(true)

        // Verify TAR contents
        const listResult = await spawn('tar', ['tf', tarPath])
        expect(listResult.stdout).toContain('hello.txt')
        expect(listResult.stdout).toContain('data.json')
        expect(listResult.stdout).toContain('subdir/nested.txt')
      })

      it('should create compressed TAR.GZ archive', async () => {
        const testDir = path.join(testTmpDir, 'tar-compressed')
        await safeMkdir(testDir)

        // Create test files
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'large.txt'), 'X'.repeat(10_000))

        // Create TAR.GZ
        const tarGzPath = path.join(testDir, 'vfs.tar.gz')
        const tarResult = await spawn(
          'tar',
          ['czf', tarGzPath, '-C', vfsDir, '.'],
          { cwd: testDir },
        )
        expect(tarResult.code).toBe(0)
        expect(existsSync(tarGzPath)).toBe(true)

        // Verify compression (should be smaller)
        const tarSize =
          (await fs.stat(path.join(testDir, '../tar-uncompressed/vfs.tar')))
            .size || 10_000
        const tarGzSize = (await fs.stat(tarGzPath)).size
        expect(tarGzSize).toBeLessThan(tarSize)
      })
    })

    describe('VFS + SEA dual resource injection', () => {
      it(`should inject both NODE_SEA_BLOB and ${SMOL_VFS_BLOB}`, async () => {
        const testDir = path.join(testTmpDir, 'dual-injection')
        await safeMkdir(testDir)

        // Create SEA app that reads from VFS
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const fs = require('fs')
const path = require('path')

// Check VFS
const vfsBinding = process.binding('smol_vfs')
if (vfsBinding && vfsBinding.hasVFSBlob()) {
  console.log('VFS_AVAILABLE')

  // Initialize VFS using process.smol API
  const vfs = process.smol.vfs.initVFS()

  if (vfs) {
    console.log('VFS_INITIALIZED')
    console.log('VFS_SIZE=' + vfs.size)
  }
} else {
  console.log('VFS_NOT_AVAILABLE')
}
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // Generate SEA blob
        // SEA blob will be generated by binject from sea-config.json

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'VFS file content')

        // Create VFS TAR (disable macOS resource forks)
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy binary
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        // Inject both SEA and VFS in a single operation
        const injectResult = await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(injectResult.code).toBe(0)

        // Test execution
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('VFS_AVAILABLE')
        expect(execResult.stdout).toContain('VFS_INITIALIZED')
        expect(execResult.stdout).toContain('VFS_SIZE=')
      })
    })

    describe('VFS extraction to ~/.socket/_dlx/', () => {
      it('should extract VFS to cache directory on first run', async () => {
        const testDir = path.join(testTmpDir, 'vfs-extraction')
        await safeMkdir(testDir)

        // Create SEA app that extracts VFS files
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const fs = require('fs')
const path = require('path')
const { createHash } = require('crypto')
const os = require('os')

// VFS extraction logic (similar to binary-compressed)
const DLX_DIR = path.join(os.homedir(), '.socket', '_dlx')

async function extractVFS() {
  const vfsBinding = process.binding('smol_vfs')
  if (!vfsBinding || !vfsBinding.hasVFSBlob()) {
    console.log('NO_VFS')
    return
  }

  // Get VFS blob
  const vfsBlob = vfsBinding.getVFSBlob()
  if (!vfsBlob) {
    console.log('EMPTY_VFS')
    return
  }

  // Calculate hash for cache directory
  const hash = createHash('sha256').update(Buffer.from(vfsBlob)).digest('hex').slice(0, 16)
  const cacheDir = path.join(DLX_DIR, hash)

  console.log('CACHE_DIR=' + cacheDir)

  // Check if already extracted
  if (fs.existsSync(cacheDir)) {
    console.log('CACHE_HIT')
    return
  }

  // Create cache directory
  fs.mkdirSync(cacheDir, { recursive: true })

  // Initialize VFS using process.smol API
  const vfs = process.smol.vfs.initVFS()

  if (!vfs) {
    console.log('VFS_INIT_FAILED')
    return
  }

  // Extract all files
  let extracted = 0
  for (const [filepath, content] of vfs) {
    if (content === null) continue; // Skip directories

    const targetPath = path.join(cacheDir, filepath)
    fs.mkdirSync(path.dirname(targetPath), { recursive: true })
    fs.writeFileSync(targetPath, content)
    extracted++
  }

  console.log('EXTRACTED=' + extracted)
}

extractVFS().catch(err => {
  console.error('ERROR=' + err.message)
  process.exit(1)
})
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // SEA blob will be generated by binject from sea-config.json

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'file1.txt'), 'Content 1')
        await fs.writeFile(path.join(vfsDir, 'file2.txt'), 'Content 2')
        await safeMkdir(path.join(vfsDir, 'subdir'))
        await fs.writeFile(
          path.join(vfsDir, 'subdir', 'file3.txt'),
          'Content 3',
        )

        // Create VFS TAR (disable macOS resource forks)
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy and inject
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )

        // First run: should extract
        const firstRun = await spawn(seaBinary, [])
        expect(firstRun.code).toBe(0)
        expect(firstRun.stdout).toContain('CACHE_DIR=')
        expect(firstRun.stdout).toContain('EXTRACTED=3')

        // Extract cache directory from output
        const cacheDirMatch = firstRun.stdout.match(/CACHE_DIR=(.+)/)
        expect(cacheDirMatch).toBeTruthy()
        const cacheDir = cacheDirMatch[1].trim()
        createdCacheDirs.push(cacheDir)

        // Verify extraction
        expect(existsSync(cacheDir)).toBe(true)
        expect(existsSync(path.join(cacheDir, 'file1.txt'))).toBe(true)
        expect(existsSync(path.join(cacheDir, 'file2.txt'))).toBe(true)
        expect(existsSync(path.join(cacheDir, 'subdir', 'file3.txt'))).toBe(
          true,
        )

        // Verify content
        const content1 = await fs.readFile(
          path.join(cacheDir, 'file1.txt'),
          'utf8',
        )
        expect(content1).toBe('Content 1')

        // Second run: should hit cache
        const secondRun = await spawn(seaBinary, [])
        expect(secondRun.code).toBe(0)
        expect(secondRun.stdout).toContain('CACHE_HIT')
      })
    })

    describe('VFS TAR format support', () => {
      it('should support .tar (uncompressed) format', async () => {
        const testDir = path.join(testTmpDir, 'tar-format')
        await safeMkdir(testDir)

        // Create SEA app that reads from VFS
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const vfsBinding = process.binding('smol_vfs')
if (vfsBinding && vfsBinding.hasVFSBlob()) {
  const vfs = process.smol.vfs.initVFS()
  if (vfs) {
    console.log('TAR_FORMAT=success')
    console.log('VFS_SIZE=' + vfs.size)
  }
}
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'TAR format test')

        // Create uncompressed TAR
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy binary and inject
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )

        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('TAR_FORMAT=success')
      })

      it('should support .tgz (gzip-compressed TAR) format', async () => {
        const testDir = path.join(testTmpDir, 'tgz-format')
        await safeMkdir(testDir)

        // Create SEA app that reads from VFS
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const vfsBinding = process.binding('smol_vfs')
if (vfsBinding && vfsBinding.hasVFSBlob()) {
  const vfs = process.smol.vfs.initVFS()
  if (vfs) {
    console.log('TGZ_FORMAT=success')
    console.log('VFS_SIZE=' + vfs.size)
  }
}
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'TGZ format test')

        // Create gzip-compressed TAR (.tgz)
        const vfsTgz = path.join(testDir, 'vfs.tgz')
        await spawn('tar', ['czf', vfsTgz, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy binary and inject
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTgz },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )

        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('TGZ_FORMAT=success')
      })

      it('should support PAX extended headers for long filenames', async () => {
        const testDir = path.join(testTmpDir, 'tar-pax')
        await safeMkdir(testDir)

        // Create file with long name (150 chars)
        // Note: macOS filesystem limits filenames to 255 bytes, but USTAR format
        // only supports 100 chars, so 150 chars requires PAX extended headers
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        const longName = `${'a'.repeat(150)}.txt`
        await fs.writeFile(path.join(vfsDir, longName), 'Long name content')

        // Create TAR with PAX format
        const tarPath = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', tarPath, '--format=posix', '-C', vfsDir, '.'])

        expect(existsSync(tarPath)).toBe(true)

        // Verify TAR contains long filename
        const listResult = await spawn('tar', ['tf', tarPath])
        expect(listResult.stdout).toContain(longName)
      })
    })

    describe('VFS extraction path validation', () => {
      it('should use SHA-256 hash (16 hex chars) for cache directory', async () => {
        const testDir = path.join(testTmpDir, 'vfs-hash-validation')
        await safeMkdir(testDir)

        // Create SEA app that validates hash format
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const vfsBinding = process.binding('smol_vfs')
if (vfsBinding && vfsBinding.hasVFSBlob()) {
  const { createHash } = require('crypto')
  const vfsBlob = vfsBinding.getVFSBlob()
  const fullHash = createHash('sha256').update(Buffer.from(vfsBlob)).digest('hex')
  const shortHash = fullHash.slice(0, 16)

  console.log('FULL_HASH_LENGTH=' + fullHash.length)
  console.log('SHORT_HASH_LENGTH=' + shortHash.length)
  console.log('SHORT_HASH=' + shortHash)

  // Validate it's hex
  const isHex = /^[0-9a-f]+$/.test(shortHash)
  console.log('IS_HEX=' + isHex)
}
`,
        )

        // Create and inject VFS
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        await spawn(
          finalBinaryPath,
          ['--experimental-sea-config', 'sea-config.json'],
          { cwd: testDir },
        )

        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'test')

        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'])

        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          { testDir },
        )

        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('FULL_HASH_LENGTH=64')
        expect(execResult.stdout).toContain('SHORT_HASH_LENGTH=16')
        expect(execResult.stdout).toContain('IS_HEX=true')

        // Validate hash format
        const hashMatch = execResult.stdout.match(/SHORT_HASH=([\da-f]{16})/)
        expect(hashMatch).toBeTruthy()
      })

      it('should match compression extraction pattern structure', () => {
        // VFS: <cache>/<sha256-16chars>/
        const vfsPattern = /^[\da-f]{16}$/

        // Compression: <cache>/<sha512-16chars>-<platform>-<arch>/
        const compressionPattern =
          /^[\da-f]{16}-(macos|linux|windows)-(x64|arm64|ia32|arm)$/

        // VFS uses simpler hash-only pattern
        expect('a1b2c3d4e5f67890'.match(vfsPattern)).toBeTruthy()
        expect('a1b2c3d4e5f67890'.match(compressionPattern)).toBeFalsy()

        // Compression uses hash-platform-arch pattern
        expect(
          'a1b2c3d4e5f67890-macos-arm64'.match(compressionPattern),
        ).toBeTruthy()
        expect('a1b2c3d4e5f67890-macos-arm64'.match(vfsPattern)).toBeFalsy()
      })
    })

    describe('Directory extraction with process.smol.mount()', () => {
      it('should recursively extract directories using mount()', async () => {
        const testDir = path.join(testTmpDir, 'mount-directory')
        await safeMkdir(testDir)

        // Create SEA app that uses process.smol.mount() to extract directories
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
const fs = require('fs')
const path = require('path')

// Test process.smol.mount() API for directory extraction
if (process.smol && process.smol.mount) {
  try {
    // Test 1: Mount directory WITHOUT trailing slash
    const dir1 = process.smol.mount('/snapshot/node_modules/test-package')
    console.log('DIR1_PATH=' + dir1)

    // Verify directory was extracted
    const dir1Exists = fs.existsSync(dir1)
    console.log('DIR1_EXISTS=' + dir1Exists)

    // Test 2: Mount directory WITH trailing slash (should work identically)
    const dir2 = process.smol.mount('/snapshot/node_modules/test-package/')
    console.log('DIR2_PATH=' + dir2)
    console.log('PATHS_MATCH=' + (dir1 === dir2))

    // Test 3: Verify all files were extracted recursively
    const indexPath = path.join(dir1, 'index.js')
    const nestedPath = path.join(dir1, 'subdir', 'nested.js')

    console.log('INDEX_EXISTS=' + fs.existsSync(indexPath))
    console.log('NESTED_EXISTS=' + fs.existsSync(nestedPath))

    // Test 4: Verify file contents
    const indexContent = fs.readFileSync(indexPath, 'utf8')
    console.log('INDEX_CONTENT=' + indexContent.trim())

    const nestedContent = fs.readFileSync(nestedPath, 'utf8')
    console.log('NESTED_CONTENT=' + nestedContent.trim())

    // Test 5: Mount with backslashes (should normalize automatically)
    const dir3 = process.smol.mount('\\\\snapshot\\\\node_modules\\\\test-package')
    console.log('BACKSLASH_PATHS_MATCH=' + (dir1 === dir3))

    // Test 6: Mount with backslashes AND trailing backslash (edge case)
    const dir4 = process.smol.mount('\\\\snapshot\\\\node_modules\\\\test-package\\\\')
    console.log('BACKSLASH_TRAILING_PATHS_MATCH=' + (dir1 === dir4))

    console.log('MOUNT_DIRECTORY_SUCCESS')
  } catch (err) {
    console.log('MOUNT_ERROR=' + err.message)
  }
} else {
  console.log('NO_SMOL_MOUNT_API')
}
`,
        )

        // Create VFS content with directory structure
        const vfsDir = path.join(testDir, 'vfs-content')
        const pkgDir = path.join(vfsDir, 'node_modules', 'test-package')
        await safeMkdir(pkgDir)
        await safeMkdir(path.join(pkgDir, 'subdir'))

        await fs.writeFile(
          path.join(pkgDir, 'index.js'),
          'module.exports = "hello"',
        )
        await fs.writeFile(
          path.join(pkgDir, 'package.json'),
          '{"name":"test-package"}',
        )
        await fs.writeFile(
          path.join(pkgDir, 'subdir', 'nested.js'),
          'module.exports = "nested"',
        )

        // Create VFS TAR
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // Copy binary and inject
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )

        // Execute and verify
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('MOUNT_DIRECTORY_SUCCESS')
        expect(execResult.stdout).toContain('DIR1_EXISTS=true')
        expect(execResult.stdout).toContain('PATHS_MATCH=true')
        expect(execResult.stdout).toContain('INDEX_EXISTS=true')
        expect(execResult.stdout).toContain('NESTED_EXISTS=true')
        expect(execResult.stdout).toContain(
          'INDEX_CONTENT=module.exports = "hello"',
        )
        expect(execResult.stdout).toContain(
          'NESTED_CONTENT=module.exports = "nested"',
        )
        expect(execResult.stdout).toContain('BACKSLASH_PATHS_MATCH=true')
        expect(execResult.stdout).toContain(
          'BACKSLASH_TRAILING_PATHS_MATCH=true',
        )
      })
    })

    describe('VFS mode flags', () => {
      it('should support --vfs-on-disk mode (default)', async () => {
        const testDir = path.join(testTmpDir, 'vfs-on-disk')
        await safeMkdir(testDir)

        // Create SEA app
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
console.log('VFS_MODE=on-disk')
console.log('VFS_AVAILABLE=' + (typeof process._vfs !== 'undefined'))
`,
        )

        // Generate SEA blob
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )
        await spawn(
          finalBinaryPath,
          ['--experimental-sea-config', 'sea-config.json'],
          { cwd: testDir },
        )

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'on-disk mode')

        // Create VFS TAR (disable macOS resource forks)
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy binary and inject with --vfs-on-disk
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        const result = await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            vfsMode: 'on-disk',
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(result.code).toBe(0)

        // Execute and verify
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('VFS_MODE=on-disk')
      })

      it('should support --vfs-in-memory mode', async () => {
        const testDir = path.join(testTmpDir, 'vfs-in-memory')
        await safeMkdir(testDir)

        // Create SEA app
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
console.log('VFS_MODE=in-memory')
console.log('VFS_AVAILABLE=' + (typeof process._vfs !== 'undefined'))
`,
        )

        // Generate SEA blob
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )
        await spawn(
          finalBinaryPath,
          ['--experimental-sea-config', 'sea-config.json'],
          { cwd: testDir },
        )

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await safeMkdir(vfsDir)
        await fs.writeFile(path.join(vfsDir, 'test.txt'), 'in-memory mode')

        // Create VFS TAR (disable macOS resource forks)
        const vfsTar = path.join(testDir, 'vfs.tar')
        await spawn('tar', ['cf', vfsTar, '-C', vfsDir, '.'], {
          env: { ...process.env, COPYFILE_DISABLE: '1' },
        })

        // Copy binary and inject with --vfs-in-memory
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        const result = await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTar },
          {
            testDir,
            vfsMode: 'in-memory',
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(result.code).toBe(0)

        // Execute and verify
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('VFS_MODE=in-memory')
      })

      it('should support --vfs-compat mode (no file bundling)', async () => {
        const testDir = path.join(testTmpDir, 'vfs-compat')
        await safeMkdir(testDir)

        // Create SEA app
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
console.log('VFS_MODE=compat')
console.log('VFS_AVAILABLE=' + (typeof process._vfs !== 'undefined'))
`,
        )

        // Generate SEA blob
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )
        await spawn(
          finalBinaryPath,
          ['--experimental-sea-config', 'sea-config.json'],
          { cwd: testDir },
        )

        // Copy binary and inject with --vfs-compat (no VFS file needed)
        const seaBinary = path.join(testDir, 'app')
        await fs.copyFile(finalBinaryPath, seaBinary)
        await fs.chmod(seaBinary, 0o755)

        const result = await runBinject(
          seaBinary,
          'BOTH',
          { sea: 'app.blob', vfs: null },
          {
            testDir,
            vfsMode: 'compat',
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(result.code).toBe(0)

        // Execute and verify
        const execResult = await spawn(seaBinary, [])
        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('VFS_MODE=compat')
      })
    })
  },
)
