/**
 * @fileoverview Generate embedded stubs for binpress
 *
 * This script:
 * 1. Downloads pre-built self-extracting stubs from GitHub releases
 * 2. Extracts them from tarballs
 * 3. Converts them to C arrays
 * 4. Generates embedded_stubs.c with all stub binaries
 *
 * Stubs are downloaded for:
 * - darwin-arm64, darwin-x64
 * - linux-arm64, linux-x64, linux-arm64-musl, linux-x64-musl
 * - win-arm64, win-x64
 */

import { promises as fs } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import { safeDelete, safeMkdir } from '@socketsecurity/lib/fs'
import { getDefaultLogger } from '@socketsecurity/lib/logger'
import { spawn } from '@socketsecurity/lib/spawn'

import { getBuildMode } from '../../build-infra/lib/constants.mjs'
import {
  downloadReleaseAsset,
  getLatestRelease,
} from '../../build-infra/lib/github-releases.mjs'

const logger = getDefaultLogger()

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const BINPRESS_DIR = path.dirname(__dirname)
const BUILD_MODE = getBuildMode()
const BUILD_DIR = path.join(BINPRESS_DIR, 'build', BUILD_MODE)
// Stubs download to centralized location
const DOWNLOAD_DIR = path.join(
  BINPRESS_DIR,
  '..',
  'build-infra',
  'build',
  'downloaded',
  'stubs',
)
const OUTPUT_FILE = path.join(BUILD_DIR, 'embedded_stubs.c')

logger.info('Generating embedded stubs from releases...')

// Ensure build directory exists
await safeMkdir(BUILD_DIR)

// Get latest stubs release
const stubsTag = await getLatestRelease('stubs')
if (!stubsTag) {
  throw new Error(
    'No stubs release found. Please run the stubs workflow first.',
  )
}

logger.info(`Using stubs release: ${stubsTag}`)

/**
 * Download and extract a stub for a specific platform-arch
 */
async function downloadStub(platform, arch, libc) {
  const libcSuffix = libc ? `-${libc}` : ''
  const platformName = `${platform}-${arch}${libcSuffix}`
  logger.info(`  Downloading ${platformName} stub...`)

  // Determine asset name (all hyphens, following lief convention)
  const assetName = `smol-stub-${platformName}.tar.gz`

  // Download to build/downloaded/stubs/{platform-arch}/
  const platformDir = path.join(DOWNLOAD_DIR, platformName)
  await safeMkdir(platformDir)
  const tarballPath = path.join(platformDir, assetName)

  try {
    await downloadReleaseAsset(stubsTag, assetName, tarballPath, {
      quiet: true,
    })

    // Extract tarball
    const result = await spawn('tar', ['-xzf', assetName], {
      cwd: platformDir,
      stdio: 'pipe',
    })

    if (result.code !== 0) {
      logger.warn(`  Failed to extract ${platformName} stub`)
      return undefined
    }

    // Determine extracted file name
    const extractedName = platform === 'win' ? 'smol_stub.exe' : 'smol_stub'
    const extractedPath = path.join(platformDir, extractedName)

    // Move to build directory with platform-specific name for embedding
    const stubOut = path.join(
      BUILD_DIR,
      `smol_stub_${platform}_${arch}${libc ? `_${libc}` : ''}`,
    )
    await fs.rename(extractedPath, stubOut)

    const stats = await fs.stat(stubOut)
    logger.info(
      `  âœ“ ${platformName} stub (${(stats.size / 1024).toFixed(1)}KB)`,
    )

    // Remove tarball after extraction
    await safeDelete(tarballPath)

    return stubOut
  } catch (err) {
    logger.group()
    logger.error(`Failed to download ${platformName} stub: ${err.message}`)
    logger.groupEnd()
    throw new Error(
      `Failed to download required stub ${platformName}. ` +
        `All stubs must be available in the release: ${stubsTag}`,
    )
  }
}

/**
 * Convert binary to C array
 */
async function binaryToCArray(stubPath, varName) {
  // Read binary
  const data = await fs.readFile(stubPath)

  // Convert to hex string
  const hexBytes = []
  for (let i = 0; i < data.length; i++) {
    if (i % 12 === 0) {
      hexBytes.push('\n  ')
    }
    hexBytes.push(`0x${data[i].toString(16).padStart(2, '0')}`)
    if (i < data.length - 1) {
      hexBytes.push(', ')
    }
  }

  return `const unsigned char ${varName}[] = {${hexBytes.join('')}\n};\nconst size_t ${varName}_len = ${data.length};\n\n`
}

// Start output file
let output = `/**
 * @fileoverview Embedded stub binaries
 *
 * Auto-generated by scripts/generate-embedded-stubs.mjs
 * DO NOT EDIT MANUALLY
 *
 * Contains pre-compiled self-extracting stub binaries as C arrays.
 * Downloaded from GitHub release: ${stubsTag}
 */

#include <stddef.h>

`

// Download all stubs
logger.info('Downloading stubs...')
const stubDarwinArm64 = await downloadStub('darwin', 'arm64')
const stubDarwinX64 = await downloadStub('darwin', 'x64')
const stubLinuxArm64 = await downloadStub('linux', 'arm64')
const stubLinuxX64 = await downloadStub('linux', 'x64')
const stubLinuxArm64Musl = await downloadStub('linux', 'arm64', 'musl')
const stubLinuxX64Musl = await downloadStub('linux', 'x64', 'musl')
const stubWinArm64 = await downloadStub('win', 'arm64')
const stubWinX64 = await downloadStub('win', 'x64')

logger.info('\nEmbedding stubs into C arrays...')

// Convert to C arrays
output += await binaryToCArray(stubDarwinArm64, 'stub_darwin_arm64')
output += await binaryToCArray(stubDarwinX64, 'stub_darwin_x64')
output += await binaryToCArray(stubLinuxArm64, 'stub_linux_arm64')
output += await binaryToCArray(stubLinuxX64, 'stub_linux_x64')
output += await binaryToCArray(stubLinuxArm64Musl, 'stub_linux_arm64_musl')
output += await binaryToCArray(stubLinuxX64Musl, 'stub_linux_x64_musl')
output += await binaryToCArray(stubWinArm64, 'stub_win_arm64')
output += await binaryToCArray(stubWinX64, 'stub_win_x64')

// Write output
await fs.writeFile(OUTPUT_FILE, output, 'utf-8')

logger.success(`Generated: ${OUTPUT_FILE}`)

// Print summary
logger.info('\nStub summary:')
const stubs = [
  ['darwin-arm64', stubDarwinArm64],
  ['darwin-x64', stubDarwinX64],
  ['linux-arm64', stubLinuxArm64],
  ['linux-x64', stubLinuxX64],
  ['linux-arm64-musl', stubLinuxArm64Musl],
  ['linux-x64-musl', stubLinuxX64Musl],
  ['win-arm64', stubWinArm64],
  ['win-x64', stubWinX64],
]

for (const [name, stubPath] of stubs) {
  const stats = await fs.stat(stubPath)
  logger.info(`  ${name}: ${(stats.size / 1024).toFixed(1)}KB`)
}

// Clean up downloaded stubs from build directory
for (const [, stubPath] of stubs) {
  await safeDelete(stubPath)
}
