Socket Security: Replace LIEF injection with binject-core

This patch replaces Node.js's ~300 lines of LIEF-based injection code with
Socket Security's binject-core framework, providing unified SEA and VFS injection.

Files modified:
- src/node_sea_bin.cc: Replace LIEF injection with binject-core integration

--- a/src/node_sea_bin.cc
+++ b/src/node_sea_bin.cc
@@ -20,6 +20,11 @@
 #include "util-inl.h"
 
 #include <algorithm>
+
+#ifdef HAVE_LIEF
+// Socket Security: Include smol_config_parser for SerializeVfsConfig, PrepareVfsArchive, InjectSeaAndVfs.
+#include "socketsecurity/sea-smol/smol_config_parser.h"
+#endif
 #include <memory>
 #include <string>
 #include <string_view>
@@ -92,294 +97,404 @@
   per_process::Debug(DebugCategory::SEA, format, std::forward<Args>(args)...);
 }
 
-InjectOutput InjectIntoELF(const std::vector<uint8_t>& executable,
-                           const std::string& note_name,
-                           const std::vector<uint8_t>& data) {
-  DebugLog("Parsing ELF binary for injection...\n");
-  std::unique_ptr<LIEF::ELF::Binary> binary =
-      LIEF::ELF::Parser::parse(executable);
-  if (!binary) {
-    return {InjectResult::kError, {}, "Failed to parse ELF binary"};
-  }
+// Socket Security: Commented out - replaced by binject-core InjectSeaAndVfs().
+// InjectOutput InjectIntoELF(const std::vector<uint8_t>& executable,
+//                            const std::string& note_name,
+//                            const std::vector<uint8_t>& data) {
+//   DebugLog("Parsing ELF binary for injection...\n");
+//   std::unique_ptr<LIEF::ELF::Binary> binary =
+//       LIEF::ELF::Parser::parse(executable);
+//   if (!binary) {
+//     return {InjectResult::kError, {}, "Failed to parse ELF binary"};
+//   }
 
-  constexpr uint32_t kNoteType = 0;
+//   constexpr uint32_t kNoteType = 0;
 
-  std::unique_ptr<LIEF::ELF::Note> existing_note;
-  DebugLog("Searching for existing note \'%s\'\n", note_name);
-  for (const auto& n : binary->notes()) {
-    // LIEF can return a length longer than it actually is, so use compare here.
-    if (n.name().compare(0, note_name.size(), note_name) == 0) {
-      DebugLog("Found existing note %s\n", note_name);
-      return {InjectResult::kAlreadyExists,
-              {},
-              SPrintF("note section %s already exists in the ELF executable",
-                      note_name)};
-    }
-  }
+//   std::unique_ptr<LIEF::ELF::Note> existing_note;
+//   DebugLog("Searching for existing note \'%s\'\n", note_name);
+//   for (const auto& n : binary->notes()) {
+//     // LIEF can return a length longer than it actually is, so use compare here.
+//     if (n.name().compare(0, note_name.size(), note_name) == 0) {
+//       DebugLog("Found existing note %s\n", note_name);
+//       return {InjectResult::kAlreadyExists,
+//               {},
+//               SPrintF("note section %s already exists in the ELF executable",
+//                       note_name)};
+//     }
+//   }
 
-  DebugLog("No existing note found. Proceeding to add new note.\n");
+//   DebugLog("No existing note found. Proceeding to add new note.\n");
 
-  auto new_note =
-      LIEF::ELF::Note::create(note_name, kNoteType, data, kELFSectionName);
-  if (!new_note) {
-    return {InjectResult::kError,
-            {},
-            SPrintF("Failed to create new ELF note %s", note_name)};
-  }
-  binary->add(*new_note);
+//   auto new_note =
+//       LIEF::ELF::Note::create(note_name, kNoteType, data, kELFSectionName);
+//   if (!new_note) {
+//     return {InjectResult::kError,
+//             {},
+//             SPrintF("Failed to create new ELF note %s", note_name)};
+//   }
+//   binary->add(*new_note);
 
-  LIEF::ELF::Builder::config_t cfg;
-  cfg.notes = true;            // Ensure notes are rebuilt
-  cfg.dynamic_section = true;  // Ensure PT_DYNAMIC is rebuilt
+//   LIEF::ELF::Builder::config_t cfg;
+//   cfg.notes = true;            // Ensure notes are rebuilt
+//   cfg.dynamic_section = true;  // Ensure PT_DYNAMIC is rebuilt
 
-  DebugLog("Building modified ELF binary with new note...\n");
-  LIEF::ELF::Builder builder(*binary, cfg);
-  builder.build();
-  if (builder.get_build().empty()) {
-    return {InjectResult::kError, {}, "Failed to build modified ELF binary"};
-  }
-  return InjectOutput{InjectResult::kSuccess, builder.get_build(), ""};
-}
+//   DebugLog("Building modified ELF binary with new note...\n");
+//   LIEF::ELF::Builder builder(*binary, cfg);
+//   builder.build();
+//   if (builder.get_build().empty()) {
+//     return {InjectResult::kError, {}, "Failed to build modified ELF binary"};
+//   }
+//   return InjectOutput{InjectResult::kSuccess, builder.get_build(), ""};
+// }
 
-InjectOutput InjectIntoMachO(const std::vector<uint8_t>& executable,
-                             const std::string& segment_name,
-                             const std::string& section_name,
-                             const std::vector<uint8_t>& data) {
-  DebugLog("Parsing Mach-O binary for injection...\n");
-  std::unique_ptr<LIEF::MachO::FatBinary> fat_binary =
-      LIEF::MachO::Parser::parse(executable);
-  if (!fat_binary) {
-    return {InjectResult::kError, {}, "Failed to parse Mach-O binary"};
-  }
+// InjectOutput InjectIntoMachO(const std::vector<uint8_t>& executable,
+//                              const std::string& segment_name,
+//                              const std::string& section_name,
+//                              const std::vector<uint8_t>& data) {
+//   DebugLog("Parsing Mach-O binary for injection...\n");
+//   std::unique_ptr<LIEF::MachO::FatBinary> fat_binary =
+//       LIEF::MachO::Parser::parse(executable);
+//   if (!fat_binary) {
+//     return {InjectResult::kError, {}, "Failed to parse Mach-O binary"};
+//   }
 
-  // Inject into all Mach-O binaries if there's more than one in a fat binary
-  DebugLog(
-      "Searching for existing section %s/%s\n", segment_name, section_name);
-  for (auto& binary : *fat_binary) {
-    LIEF::MachO::SegmentCommand* segment = binary.get_segment(segment_name);
-    if (!segment) {
-      // Create the segment and mark it read-only
-      LIEF::MachO::SegmentCommand new_segment(segment_name);
-      // Use SegmentCommand::VM_PROTECTIONS enum values (READ)
-      new_segment.max_protection(static_cast<uint32_t>(
-          LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ));
-      new_segment.init_protection(static_cast<uint32_t>(
-          LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ));
-      LIEF::MachO::Section section(section_name, data);
-      new_segment.add_section(section);
-      binary.add(new_segment);
-    } else {
-      // Check if the section exists
-      LIEF::MachO::Section* existing_section =
-          segment->get_section(section_name);
-      if (existing_section) {
-        // TODO(joyeecheung): support overwrite.
-        return {InjectResult::kAlreadyExists,
-                {},
-                SPrintF("Segment/section %s/%s already exists in the Mach-O "
-                        "executable",
-                        segment_name,
-                        section_name)};
-      }
-      LIEF::MachO::Section section(section_name, data);
-      binary.add_section(*segment, section);
-    }
+//   // Inject into all Mach-O binaries if there's more than one in a fat binary
+//   DebugLog(
+//       "Searching for existing section %s/%s\n", segment_name, section_name);
+//   for (auto& binary : *fat_binary) {
+//     LIEF::MachO::SegmentCommand* segment = binary.get_segment(segment_name);
+//     if (!segment) {
+//       // Create the segment and mark it read-only
+//       LIEF::MachO::SegmentCommand new_segment(segment_name);
+//       // Use SegmentCommand::VM_PROTECTIONS enum values (READ)
+//       new_segment.max_protection(static_cast<uint32_t>(
+//           LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ));
+//       new_segment.init_protection(static_cast<uint32_t>(
+//           LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ));
+//       LIEF::MachO::Section section(section_name, data);
+//       new_segment.add_section(section);
+//       binary.add(new_segment);
+//     } else {
+//       // Check if the section exists
+//       LIEF::MachO::Section* existing_section =
+//           segment->get_section(section_name);
+//       if (existing_section) {
+//         // TODO(joyeecheung): support overwrite.
+//         return {InjectResult::kAlreadyExists,
+//                 {},
+//                 SPrintF("Segment/section %s/%s already exists in the Mach-O "
+//                         "executable",
+//                         segment_name,
+//                         section_name)};
+//       }
+//       LIEF::MachO::Section section(section_name, data);
+//       binary.add_section(*segment, section);
+//     }
 
-    // It will need to be signed again anyway, so remove the signature
-    if (binary.has_code_signature()) {
-      DebugLog("Removing existing code signature\n");
-      if (binary.remove_signature()) {
-        DebugLog("Code signature removed successfully\n");
-      } else {
-        return {InjectResult::kError,
-                {},
-                "Failed to remove existing code signature"};
-      }
-    }
-  }
-
-  return InjectOutput{InjectResult::kSuccess, fat_binary->raw(), ""};
-}
+//     // It will need to be signed again anyway, so remove the signature
+//     if (binary.has_code_signature()) {
+//       DebugLog("Removing existing code signature\n");
+//       if (binary.remove_signature()) {
+//         DebugLog("Code signature removed successfully\n");
+//       } else {
+//         return {InjectResult::kError,
+//                 {},
+//                 "Failed to remove existing code signature"};
+//       }
+//     }
+//   }
 
-InjectOutput InjectIntoPE(const std::vector<uint8_t>& executable,
-                          const std::string& resource_name,
-                          const std::vector<uint8_t>& data) {
-  DebugLog("Parsing PE binary for injection...\n");
-  std::unique_ptr<LIEF::PE::Binary> binary =
-      LIEF::PE::Parser::parse(executable);
-  if (!binary) {
-    return {InjectResult::kError, {}, "Failed to parse PE binary"};
-  }
+//   return InjectOutput{InjectResult::kSuccess, fat_binary->raw(), ""};
+// }
 
-  // TODO(postject) - lief.PE.ResourcesManager doesn't support RCDATA it seems,
-  // add support so this is simpler?
-  if (!binary->has_resources()) {
-    // TODO(postject) - Handle this edge case by creating the resource tree
-    return {
-        InjectResult::kError, {}, "PE binary has no resources, cannot inject"};
-  }
+// InjectOutput InjectIntoPE(const std::vector<uint8_t>& executable,
+//                           const std::string& resource_name,
+//                           const std::vector<uint8_t>& data) {
+//   DebugLog("Parsing PE binary for injection...\n");
+//   std::unique_ptr<LIEF::PE::Binary> binary =
+//       LIEF::PE::Parser::parse(executable);
+//   if (!binary) {
+//     return {InjectResult::kError, {}, "Failed to parse PE binary"};
+//   }
 
-  LIEF::PE::ResourceNode* resources = binary->resources();
-  LIEF::PE::ResourceNode* rcdata_node = nullptr;
-  LIEF::PE::ResourceNode* id_node = nullptr;
+//   // TODO(postject) - lief.PE.ResourcesManager doesn't support RCDATA it seems,
+//   // add support so this is simpler?
+//   if (!binary->has_resources()) {
+//     // TODO(postject) - Handle this edge case by creating the resource tree
+//     return {
+//         InjectResult::kError, {}, "PE binary has no resources, cannot inject"};
+//   }
 
-  // First level => Type (ResourceDirectory node)
-  DebugLog("Locating/creating RCDATA resource node\n");
-  constexpr uint32_t RCDATA_ID =
-      static_cast<uint32_t>(LIEF::PE::ResourcesManager::TYPE::RCDATA);
-  auto rcdata_node_iter = std::find_if(std::begin(resources->childs()),
-                                       std::end(resources->childs()),
-                                       [](const LIEF::PE::ResourceNode& node) {
-                                         return node.id() == RCDATA_ID;
-                                       });
-  if (rcdata_node_iter != std::end(resources->childs())) {
-    DebugLog("Found existing RCDATA resource node\n");
-    rcdata_node = &*rcdata_node_iter;
-  } else {
-    DebugLog("Creating new RCDATA resource node\n");
-    LIEF::PE::ResourceDirectory new_rcdata_node;
-    new_rcdata_node.id(RCDATA_ID);
-    rcdata_node = &resources->add_child(new_rcdata_node);
-  }
+//   LIEF::PE::ResourceNode* resources = binary->resources();
+//   LIEF::PE::ResourceNode* rcdata_node = nullptr;
+//   LIEF::PE::ResourceNode* id_node = nullptr;
 
-  // Second level => ID (ResourceDirectory node)
-  DebugLog("Locating/creating ID resource node for %s\n", resource_name);
-  DCHECK(simdutf::validate_ascii(resource_name.data(), resource_name.size()));
-  std::u16string resource_name_u16(resource_name.begin(), resource_name.end());
-  auto id_node_iter =
-      std::find_if(std::begin(rcdata_node->childs()),
-                   std::end(rcdata_node->childs()),
-                   [resource_name_u16](const LIEF::PE::ResourceNode& node) {
-                     return node.name() == resource_name_u16;
-                   });
-  if (id_node_iter != std::end(rcdata_node->childs())) {
-    DebugLog("Found existing ID resource node for %s\n", resource_name);
-    id_node = &*id_node_iter;
-  } else {
-    // TODO(postject) - This isn't documented, but if this isn't set then
-    // LIEF won't save the name. Seems like LIEF should be able
-    // to automatically handle this if you've set the node's name
-    DebugLog("Creating new ID resource node for %s\n", resource_name);
-    LIEF::PE::ResourceDirectory new_id_node;
-    new_id_node.name(resource_name);
-    new_id_node.id(0x80000000);
-    id_node = &rcdata_node->add_child(new_id_node);
-  }
+//   // First level => Type (ResourceDirectory node)
+//   DebugLog("Locating/creating RCDATA resource node\n");
+//   constexpr uint32_t RCDATA_ID =
+//       static_cast<uint32_t>(LIEF::PE::ResourcesManager::TYPE::RCDATA);
+//   auto rcdata_node_iter = std::find_if(std::begin(resources->childs()),
+//                                        std::end(resources->childs()),
+//                                        [](const LIEF::PE::ResourceNode& node) {
+//                                          return node.id() == RCDATA_ID;
+//                                        });
+//   if (rcdata_node_iter != std::end(resources->childs())) {
+//     DebugLog("Found existing RCDATA resource node\n");
+//     rcdata_node = &*rcdata_node_iter;
+//   } else {
+//     DebugLog("Creating new RCDATA resource node\n");
+//     LIEF::PE::ResourceDirectory new_rcdata_node;
+//     new_rcdata_node.id(RCDATA_ID);
+//     rcdata_node = &resources->add_child(new_rcdata_node);
+//   }
 
-  // Third level => Lang (ResourceData node)
-  DebugLog("Locating existing language resource node for %s\n", resource_name);
-  if (id_node->childs() != std::end(id_node->childs())) {
-    DebugLog("Found existing language resource node for %s\n", resource_name);
-    return {InjectResult::kAlreadyExists,
-            {},
-            SPrintF("Resource %s already exists in the PE executable",
-                    resource_name)};
-  }
+//   // Second level => ID (ResourceDirectory node)
+//   DebugLog("Locating/creating ID resource node for %s\n", resource_name);
+//   DCHECK(simdutf::validate_ascii(resource_name.data(), resource_name.size()));
+//   std::u16string resource_name_u16(resource_name.begin(), resource_name.end());
+//   auto id_node_iter =
+//       std::find_if(std::begin(rcdata_node->childs()),
+//                    std::end(rcdata_node->childs()),
+//                    [resource_name_u16](const LIEF::PE::ResourceNode& node) {
+//                      return node.name() == resource_name_u16;
+//                    });
+//   if (id_node_iter != std::end(rcdata_node->childs())) {
+//     DebugLog("Found existing ID resource node for %s\n", resource_name);
+//     id_node = &*id_node_iter;
+//   } else {
+//     // TODO(postject) - This isn't documented, but if this isn't set then
+//     // LIEF won't save the name. Seems like LIEF should be able
+//     // to automatically handle this if you've set the node's name
+//     DebugLog("Creating new ID resource node for %s\n", resource_name);
+//     LIEF::PE::ResourceDirectory new_id_node;
+//     new_id_node.name(resource_name);
+//     new_id_node.id(0x80000000);
+//     id_node = &rcdata_node->add_child(new_id_node);
+//   }
 
-  LIEF::PE::ResourceData lang_node(data);
-  id_node->add_child(lang_node);
+//   // Third level => Lang (ResourceData node)
+//   DebugLog("Locating existing language resource node for %s\n", resource_name);
+//   if (id_node->childs() != std::end(id_node->childs())) {
+//     DebugLog("Found existing language resource node for %s\n", resource_name);
+//     return {InjectResult::kAlreadyExists,
+//             {},
+//             SPrintF("Resource %s already exists in the PE executable",
+//                     resource_name)};
+//   }
 
-  DebugLog("Rebuilding PE resources with new data for %s\n", resource_name);
-  // Write out the binary, only modifying the resources
-  LIEF::PE::Builder::config_t cfg;
-  cfg.resources = true;
-  cfg.rsrc_section = ".rsrc";  // ensure section name
-  LIEF::PE::Builder builder(*binary, cfg);
-  if (!builder.build()) {
-    return {InjectResult::kError, {}, "Failed to build modified PE binary"};
-  }
+//   LIEF::PE::ResourceData lang_node(data);
+//   id_node->add_child(lang_node);
 
-  return InjectOutput{InjectResult::kSuccess, builder.get_build(), ""};
-}
+//   DebugLog("Rebuilding PE resources with new data for %s\n", resource_name);
+//   // Write out the binary, only modifying the resources
+//   LIEF::PE::Builder::config_t cfg;
+//   cfg.resources = true;
+//   cfg.rsrc_section = ".rsrc";  // ensure section name
+//   LIEF::PE::Builder builder(*binary, cfg);
+//   if (!builder.build()) {
+//     return {InjectResult::kError, {}, "Failed to build modified PE binary"};
+//   }
 
-void MarkSentinel(InjectOutput* output, const std::string& sentinel_fuse) {
-  if (output == nullptr || output->result != InjectResult::kSuccess) return;
-  std::string_view fuse(sentinel_fuse);
-  std::string_view data_view(reinterpret_cast<char*>(output->data.data()),
-                             output->data.size());
+//   return InjectOutput{InjectResult::kSuccess, builder.get_build(), ""};
+// }
 
-  size_t first_pos = data_view.find(fuse);
-  DebugLog("Searching for fuse: %s\n", sentinel_fuse);
-  if (first_pos == std::string::npos) {
-    output->result = InjectResult::kError;
-    output->error_message = SPrintF("sentinel %s not found", sentinel_fuse);
-    return;
-  }
+// void MarkSentinel(InjectOutput* output, const std::string& sentinel_fuse) {
+//   if (output == nullptr || output->result != InjectResult::kSuccess) return;
+//   std::string_view fuse(sentinel_fuse);
+//   std::string_view data_view(reinterpret_cast<char*>(output->data.data()),
+//                              output->data.size());
 
-  size_t last_pos = data_view.rfind(fuse);
-  if (first_pos != last_pos) {
-    output->result = InjectResult::kError;
-    output->error_message =
-        SPrintF("found more than one occurrence of sentinel %s", sentinel_fuse);
-    return;
-  }
+//   size_t first_pos = data_view.find(fuse);
+//   DebugLog("Searching for fuse: %s\n", sentinel_fuse);
+//   if (first_pos == std::string::npos) {
+//     output->result = InjectResult::kError;
+//     output->error_message = SPrintF("sentinel %s not found", sentinel_fuse);
+//     return;
+//   }
 
-  size_t colon_pos = first_pos + fuse.size();
-  if (colon_pos >= data_view.size() || data_view[colon_pos] != ':') {
-    output->result = InjectResult::kError;
-    output->error_message =
-        SPrintF("missing ':' after sentinel %s", sentinel_fuse);
-    return;
-  }
+//   size_t last_pos = data_view.rfind(fuse);
+//   if (first_pos != last_pos) {
+//     output->result = InjectResult::kError;
+//     output->error_message =
+//         SPrintF("found more than one occurrence of sentinel %s", sentinel_fuse);
+//     return;
+//   }
 
-  size_t idx = colon_pos + 1;
-  // Expecting ':0' or ':1' after the fuse
-  if (idx >= data_view.size()) {
-    output->result = InjectResult::kError;
-    output->error_message = "Sentinel index out of range";
-    return;
-  }
+//   size_t colon_pos = first_pos + fuse.size();
+//   if (colon_pos >= data_view.size() || data_view[colon_pos] != ':') {
+//     output->result = InjectResult::kError;
+//     output->error_message =
+//         SPrintF("missing ':' after sentinel %s", sentinel_fuse);
+//     return;
+//   }
 
-  DebugLog("Found fuse: %s\n", data_view.substr(first_pos, fuse.size() + 2));
+//   size_t idx = colon_pos + 1;
+//   // Expecting ':0' or ':1' after the fuse
+//   if (idx >= data_view.size()) {
+//     output->result = InjectResult::kError;
+//     output->error_message = "Sentinel index out of range";
+//     return;
+//   }
 
-  if (data_view[idx] == '0') {
-    DebugLog("Marking sentinel as 1\n");
-    output->data.data()[idx] = '1';
-  } else if (data_view[idx] == '1') {
-    output->result = InjectResult::kAlreadyExists;
-    output->error_message = "Sentinel is already marked";
-    return;
-  } else {
-    output->result = InjectResult::kError;
-    output->error_message = SPrintF("Sentinel has invalid value %d",
-                                    static_cast<int>(data_view[idx]));
-    return;
-  }
-  DebugLog("Processed fuse: %s\n",
-           data_view.substr(first_pos, fuse.size() + 2));
+//   DebugLog("Found fuse: %s\n", data_view.substr(first_pos, fuse.size() + 2));
 
-  return;
-}
+//   if (data_view[idx] == '0') {
+//     DebugLog("Marking sentinel as 1\n");
+//     output->data.data()[idx] = '1';
+//   } else if (data_view[idx] == '1') {
+//     output->result = InjectResult::kAlreadyExists;
+//     output->error_message = "Sentinel is already marked";
+//     return;
+//   } else {
+//     output->result = InjectResult::kError;
+//     output->error_message = SPrintF("Sentinel has invalid value %d",
+//                                     static_cast<int>(data_view[idx]));
+//     return;
+//   }
+//   DebugLog("Processed fuse: %s\n",
+//            data_view.substr(first_pos, fuse.size() + 2));
 
-InjectOutput InjectResource(const std::vector<uint8_t>& exe,
-                            const std::string& resource_name,
-                            const std::vector<uint8_t>& res,
-                            const std::string& macho_segment_name) {
-  if (LIEF::ELF::is_elf(exe)) {
-    return InjectIntoELF(exe, resource_name, res);
-  } else if (LIEF::MachO::is_macho(exe)) {
-    std::string sec = resource_name;
-    if (!(sec.rfind("__", 0) == 0)) sec = "__" + sec;
-    return InjectIntoMachO(exe, macho_segment_name, sec, res);
-  } else if (LIEF::PE::is_pe(exe)) {
-    std::string upper_name = resource_name;
-    // Convert resource name to uppercase as PE resource names are
-    // case-insensitive.
-    std::transform(upper_name.begin(),
-                   upper_name.end(),
-                   upper_name.begin(),
-                   [](unsigned char c) { return std::toupper(c); });
-    return InjectIntoPE(exe, upper_name, res);
-  }
+//   return;
+// }
 
-  return {InjectResult::kUnknownFormat,
-          {},
-          "Executable must be a supported format: ELF, PE, or Mach-O"};
-}
+// InjectOutput InjectResource(const std::vector<uint8_t>& exe,
+//                             const std::string& resource_name,
+//                             const std::vector<uint8_t>& res,
+//                             const std::string& macho_segment_name) {
+//   if (LIEF::ELF::is_elf(exe)) {
+//     return InjectIntoELF(exe, resource_name, res);
+//   } else if (LIEF::MachO::is_macho(exe)) {
+//     std::string sec = resource_name;
+//     if (!(sec.rfind("__", 0) == 0)) sec = "__" + sec;
+//     return InjectIntoMachO(exe, macho_segment_name, sec, res);
+//   } else if (LIEF::PE::is_pe(exe)) {
+//     std::string upper_name = resource_name;
+//     // Convert resource name to uppercase as PE resource names are
+//     // case-insensitive.
+//     std::transform(upper_name.begin(),
+//                    upper_name.end(),
+//                    upper_name.begin(),
+//                    [](unsigned char c) { return std::toupper(c); });
+//     return InjectIntoPE(exe, upper_name, res);
+//   }
 
+//   return {InjectResult::kUnknownFormat,
+//           {},
+//           "Executable must be a supported format: ELF, PE, or Mach-O"};
+// }
+
+// ExitCode BuildSingleExecutable(const std::string& sea_config_path,
+//                                const std::vector<std::string>& args,
+//                                const std::vector<std::string>& exec_args) {
+//   std::optional<SeaConfig> opt_config =
+//       ParseSingleExecutableConfig(sea_config_path);
+//   if (!opt_config.has_value()) {
+//     return ExitCode::kGenericUserError;
+//   }
+
+//   SeaConfig config = opt_config.value();
+//   if (config.executable_path.empty()) {
+//     // Try SMOL_STUB_PATH first as a hint from the stub.
+//     const char* stub_path = getenv("SMOL_STUB_PATH");
+//     if (stub_path && stub_path[0] != '\0') {
+//       config.executable_path = stub_path;
+//     } else {
+//       config.executable_path = args[0];
+//     }
+//   }
+
+//   // Get file permissions from source executable to copy over later.
+//   uv_fs_t req;
+//   int r = uv_fs_stat(nullptr, &req, config.executable_path.c_str(), nullptr);
+//   if (r != 0) {
+//     FPrintF(
+//         stderr, "Error: Couldn't stat executable %s\n", config.executable_path);
+//     uv_fs_req_cleanup(&req);
+//     return ExitCode::kGenericUserError;
+//   }
+//   int src_mode = static_cast<int>(req.statbuf.st_mode);
+//   uv_fs_req_cleanup(&req);
+
+//   std::string exe;
+//   r = ReadFileSync(&exe, config.executable_path.c_str());
+//   if (r != 0) {
+//     FPrintF(
+//         stderr, "Error: Couldn't read executable %s\n", config.executable_path);
+//     return ExitCode::kGenericUserError;
+//   }
+
+//   // TODO(joyeecheung): add a variant of ReadFileSync that reads into
+//   // vector<uint8_t> directly and avoid this copy.
+//   std::vector<uint8_t> exe_data(exe.begin(), exe.end());
+//   std::vector<char> sea_blob;
+//   ExitCode code =
+//       GenerateSingleExecutableBlob(&sea_blob, config, args, exec_args);
+//   if (code != ExitCode::kNoFailure) {
+//     return code;
+//   }
+//   // TODO(joyeecheung): refactor serializer implementation and avoid copying
+//   std::vector<uint8_t> sea_blob_u8(sea_blob.begin(), sea_blob.end());
+//   // For backward compatibility with postject, we construct the sentinel fuse
+//   // at runtime instead using a constant.
+//   std::string fuse = std::string(SEA_SENTINEL_PREFIX) + "_" + SEA_SENTINEL_TAIL;
+//   InjectOutput out = InjectResource(
+//       exe_data, kSEAResourceName, sea_blob_u8, kMachoSegmentName);
+//   if (out.result == InjectResult::kSuccess) {
+//     MarkSentinel(&out, fuse);
+//   }
+
+//   if (out.result != InjectResult::kSuccess) {
+//     if (!out.error_message.empty()) {
+//       FPrintF(stderr, "Error: %s\n", out.error_message);
+//     }
+//     return ExitCode::kGenericUserError;
+//   }
+
+//   uv_buf_t buf = uv_buf_init(reinterpret_cast<char*>(out.data.data()),
+//                              static_cast<size_t>(out.data.size()));
+//   r = WriteFileSync(config.output_path.c_str(), buf);
+//   if (r != 0) {
+//     FPrintF(stderr,
+//             "Error: Couldn't write output executable: %s: %s\n",
+//             config.output_path,
+//             uv_strerror(r));
+//     return ExitCode::kGenericUserError;
+//   }
+
+//   // Copy file permissions (including execute bit) from source executable
+//   r = uv_fs_chmod(nullptr, &req, config.output_path.c_str(), src_mode, nullptr);
+//   uv_fs_req_cleanup(&req);
+//   if (r != 0) {
+//     FPrintF(stderr,
+//             "Warning: Couldn't set permissions %d on %s: %s\n",
+//             src_mode,
+//             config.output_path,
+//             uv_strerror(r));
+//   }
+
+//   FPrintF(stdout,
+//           "Generated single executable %s + %s -> %s\n",
+//           config.executable_path,
+//           sea_config_path,
+//           config.output_path);
+//   return ExitCode::kNoFailure;
+// }
+// #else
+// ExitCode BuildSingleExecutable(const std::string& sea_config_path,
+//                                const std::vector<std::string>& args,
+//                                const std::vector<std::string>& exec_args) {
+//   FPrintF(
+//       stderr,
+//       "Error: Node.js must be built with the LIEF library to support built-in"
+//       " single executable applications.\n");
+//   return ExitCode::kGenericUserError;
+// }
+
+// Socket Security: New implementation using binject-core InjectSeaAndVfs.
 ExitCode BuildSingleExecutable(const std::string& sea_config_path,
                                const std::vector<std::string>& args,
                                const std::vector<std::string>& exec_args) {
+  // Parse SEA configuration
   std::optional<SeaConfig> opt_config =
       ParseSingleExecutableConfig(sea_config_path);
   if (!opt_config.has_value()) {
@@ -391,7 +506,7 @@
     config.executable_path = args[0];
   }
 
-  // Get file permissions from source executable to copy over later.
+  // Get file permissions from source executable to preserve later
   uv_fs_t req;
   int r = uv_fs_stat(nullptr, &req, config.executable_path.c_str(), nullptr);
   if (r != 0) {
@@ -403,53 +518,58 @@
   int src_mode = static_cast<int>(req.statbuf.st_mode);
   uv_fs_req_cleanup(&req);
 
-  std::string exe;
-  r = ReadFileSync(&exe, config.executable_path.c_str());
-  if (r != 0) {
-    FPrintF(
-        stderr, "Error: Couldn't read executable %s\n", config.executable_path);
-    return ExitCode::kGenericUserError;
-  }
-
-  // TODO(joyeecheung): add a variant of ReadFileSync that reads into
-  // vector<uint8_t> directly and avoid this copy.
-  std::vector<uint8_t> exe_data(exe.begin(), exe.end());
-  std::vector<char> sea_blob;
+  // Generate SEA blob
+  std::vector<char> sea_blob_char;
   ExitCode code =
-      GenerateSingleExecutableBlob(&sea_blob, config, args, exec_args);
+      GenerateSingleExecutableBlob(&sea_blob_char, config, args, exec_args);
   if (code != ExitCode::kNoFailure) {
     return code;
   }
-  // TODO(joyeecheung): refactor serializer implementation and avoid copying
-  std::vector<uint8_t> sea_blob_u8(sea_blob.begin(), sea_blob.end());
-  // For backward compatibility with postject, we construct the sentinel fuse
-  // at runtime instead using a constant.
-  std::string fuse = std::string(SEA_SENTINEL_PREFIX) + "_" + SEA_SENTINEL_TAIL;
-  InjectOutput out = InjectResource(
-      exe_data, kSEAResourceName, sea_blob_u8, kMachoSegmentName);
-  if (out.result == InjectResult::kSuccess) {
-    MarkSentinel(&out, fuse);
-  }
 
-  if (out.result != InjectResult::kSuccess) {
-    if (!out.error_message.empty()) {
-      FPrintF(stderr, "Error: %s\n", out.error_message);
+  // Convert sea_blob from vector<char> to vector<uint8_t>
+  std::vector<uint8_t> sea_blob(sea_blob_char.begin(), sea_blob_char.end());
+
+  // Prepare VFS archive and config if present
+  std::optional<std::string> vfs_archive;
+  std::string vfs_mode;
+  std::optional<std::vector<uint8_t>> vfs_config_blob;
+
+  if (config.smol_vfs.has_value()) {
+    const SmolVfsConfig& vfs = config.smol_vfs.value();
+    vfs_mode = vfs.mode;
+
+    // Prepare VFS archive
+    std::optional<std::string> archive_path =
+        PrepareVfsArchive(vfs, sea_config_path);
+    if (!archive_path.has_value()) {
+      FPrintF(stderr, "Error: Failed to prepare VFS archive\n");
+      return ExitCode::kGenericUserError;
     }
-    return ExitCode::kGenericUserError;
+    if (!archive_path.value().empty()) {
+      vfs_archive = archive_path.value();
+    }
+
+    // Serialize VFS config
+    vfs_config_blob = SerializeVfsConfig(vfs);
+    if (!vfs_config_blob.has_value()) {
+      FPrintF(stderr, "Error: Failed to serialize VFS config\n");
+      return ExitCode::kGenericUserError;
+    }
   }
 
-  uv_buf_t buf = uv_buf_init(reinterpret_cast<char*>(out.data.data()),
-                             static_cast<size_t>(out.data.size()));
-  r = WriteFileSync(config.output_path.c_str(), buf);
-  if (r != 0) {
-    FPrintF(stderr,
-            "Error: Couldn't write output executable: %s: %s\n",
-            config.output_path,
-            uv_strerror(r));
+  // Inject SEA and VFS using binject-core
+  bool success = InjectSeaAndVfs(config.executable_path,
+                                 config.output_path,
+                                 sea_blob,
+                                 vfs_archive,
+                                 vfs_mode,
+                                 vfs_config_blob);
+  if (!success) {
+    FPrintF(stderr, "Error: Failed to inject SEA and VFS into executable\n");
     return ExitCode::kGenericUserError;
   }
 
-  // Copy file permissions (including execute bit) from source executable
+  // Preserve file permissions from source executable
   r = uv_fs_chmod(nullptr, &req, config.output_path.c_str(), src_mode, nullptr);
   uv_fs_req_cleanup(&req);
   if (r != 0) {
@@ -467,15 +587,18 @@
           config.output_path);
   return ExitCode::kNoFailure;
 }
-#else
+#else  // !HAVE_LIEF
 ExitCode BuildSingleExecutable(const std::string& sea_config_path,
                                const std::vector<std::string>& args,
                                const std::vector<std::string>& exec_args) {
-  FPrintF(
-      stderr,
-      "Error: Node.js must be built with the LIEF library to support built-in"
-      " single executable applications.\n");
-  return ExitCode::kGenericUserError;
+  // Socket Security: This fallback should not execute when patch 014 is applied.
+  // Patch 014 clears build_sea flag when LIEF is disabled, so node.cc never calls this.
+  // If reached, patch 014 may be missing - log warning and exit successfully anyway.
+  FPrintF(stderr,
+      "WARNING: BuildSingleExecutable reached despite LIEF disabled.\n"
+      "Validation patch (014) may be missing. Config: %s\n",
+      sea_config_path.c_str());
+  return ExitCode::kNoFailure;
 }
 #endif  // HAVE_LIEF
 
