# node-smol-builder

Custom Node.js v25.x binary builder with Socket security patches.

## What it does

This package downloads the Node.js v25.x source code, applies Socket security patches, and then compiles a custom Node.js binary optimized for size and security.

## Building

```bash
pnpm run build              # Build for current platform
pnpm run build:all          # Build for all platforms
```

## Platform Support

Builds for 8 platforms:
- macOS (arm64, x64)
- Linux glibc (x64, arm64)
- Linux musl/Alpine (x64, arm64)
- Windows (x64, arm64)

## Output

Final binary: `build/<mode>/out/Final/node/node` (where `<mode>` is `dev` or `prod`).

Build stages (intermediate, managed by checkpoint system):
- Release → Stripped → Compressed → Final

**Build modes:**

| Mode | Debug Symbols | Inspector | Binary Size | Use Case |
|------|---------------|-----------|-------------|----------|
| `dev` | ✅ Enabled | ✅ Enabled | ~22 MB | Development, debugging |
| `prod` | ❌ Stripped | ❌ Disabled | ~12 MB | Production, distribution |

## Features

- Small ICU (English-only, Unicode escapes supported)
- SEA support for Single Executable Applications (generated by Node.js)
- No npm, corepack, amaro (TypeScript), NODE_OPTIONS
- No inspector (prod builds only)

## Testing

Run Node.js's official test suite (~4000+ tests) against the built binary:

```bash
pnpm build                  # Build the binary first
pnpm test:node-suite        # Test current build (auto-detects dev/prod)
pnpm test:node-suite:dev    # Test dev build
pnpm test:node-suite:prod   # Test prod build
pnpm test:node-suite -- --verbose  # Show skipped tests
```

The runner expands test patterns, filters out tests for disabled features, and runs tests in parallel.

### Coverage

**Supported** (100% of node-smol APIs):
- Core: process, buffer, stream, timers, events, fs
- Networking: http, https, http2, tls, dns, tcp, udp
- Web APIs: fetch, WebSocket, streams, crypto
- Modules: CommonJS, ESM, hooks
- Async: hooks, local storage, workers, cluster
- Standard library: path, url, util, zlib, etc.

**Excluded** (disabled features):
- ICU/Intl (small-icu, English-only)
- npm, corepack, TypeScript/amaro
- NODE_OPTIONS, inspector/debugger (prod)

## SEA Usage

### sea-config.json

The `sea-config.json` file is used at build time to create SEA blobs. See [Node.js SEA documentation](https://nodejs.org/api/single-executable-applications.html) for full details.

```json
{
  "main": "app.js",
  "output": "app.blob",
  "disableExperimentalSEAWarning": true,
  "useSnapshot": false,
  "useCodeCache": true
}
```

| Field | Type | Description |
|-------|------|-------------|
| `main` | string | Entry point JavaScript file. |
| `output` | string | Output blob filename. |
| `disableExperimentalSEAWarning` | boolean | Suppress SEA warning at startup. |
| `useSnapshot` | boolean | **Advanced** - V8 heap snapshot for fastest startup. Has restrictions. See [V8 Snapshots](#v8-snapshots). |
| `useCodeCache` | boolean | **Recommended: `true`** - Cache compiled code for faster startup. |

> **⚡ Performance Tip:** Setting `useCodeCache: true` provides **~13% faster startup** (e.g., 161ms → 140ms for large apps) at the cost of +2-3 MB binary size. This is strongly recommended for production builds where startup performance matters. See [Code Cache Performance](#code-cache-performance) for details.

> **Note:** Update checking is configured via the `smol.update` section in `sea-config.json`. See [Update Checking](#update-checking) for configuration details.

### Basic SEA (Single Executable Application)

```bash
# Create SEA config (with code caching for faster startup)
echo '{"main": "app.js", "output": "app.blob", "disableExperimentalSEAWarning": true, "useCodeCache": true}' > sea-config.json

# Copy node-smol binary
cp build/prod/out/Final/node/node ./my-app

# Inject SEA blob using binject (auto-generates blob from .json config)
binject inject -e ./my-app -o ./my-app --sea sea-config.json
```

### SEA + VFS (Virtual Filesystem)

node-smol includes a Virtual Filesystem that embeds entire application directories in TAR format:

**Features:**
- ✅ Embed entire directories (TAR format)
- ✅ Transparent `fs` module access
- ✅ Standard `require()` works
- ✅ Separate from SEA blob (future-proof)
- ✅ Independent updates possible

### Code Cache Performance

Setting `useCodeCache: true` in your `sea-config.json` significantly improves startup time by pre-compiling JavaScript code during build time.

**Performance Impact** (based on [Bun vs Node.js SEA benchmark](https://github.com/yyx990803/bun-vs-node-sea-startup)):

| Configuration | Startup Time | Binary Size | Recommendation |
|---|---|---|---|
| `useCodeCache: true` | **139.7 ms** | 117.1 MB | ✅ **Recommended for production** |
| `useCodeCache: false` | 161.3 ms | 114.7 MB | ⚠️ Only for size-critical use cases |

**Key Findings:**
- **~13% faster startup** (22ms improvement on 500 modules, 7000 functions)
- **+2.4 MB binary size** increase
- Code cache is V8-version specific (regenerate when upgrading Node.js)

**When to use `useCodeCache: true`:**
- ✅ Production applications where startup speed matters
- ✅ CLI tools invoked frequently (fast startup critical)
- ✅ Applications with 100+ modules
- ✅ Serverless functions (cold start optimization)

**When to use `useCodeCache: false`:**
- ⚠️ Very small scripts (< 10 modules) where 2MB overhead isn't worth 1-2ms gain
- ⚠️ Extremely size-constrained environments
- ⚠️ Development/debugging (faster rebuild iteration)

**Recommendation:** Use `useCodeCache: true` by default unless you have specific size constraints. The startup performance gain is significant for most real-world applications.

### V8 Snapshots

**Advanced technique for maximum startup performance**

Setting `useSnapshot: true` in your `sea-config.json` serializes the V8 heap state after your application loads, providing potentially **20-40% faster startup** compared to code caching alone.

**How it works:**
- V8 captures the heap state after loading your application code
- On subsequent startups, V8 deserializes the heap directly
- Skips parsing, compilation, and initialization of already-loaded modules
- Can bring Node.js SEA startup time closer to Bun's performance

**⚠️ Important Restrictions:**

V8 snapshots have significant limitations that make them unsuitable for many applications:

1. **No dynamic code execution** - Code using `eval()`, `new Function()`, or `vm.runInThisContext()` will fail
2. **No native addons in snapshot** - Native `.node` modules cannot be loaded during snapshot creation
3. **No file system operations** - Cannot read files or access environment during snapshot phase
4. **No network operations** - No HTTP requests, DNS lookups, or socket operations
5. **Limited Node.js APIs** - Many Node.js built-ins are restricted during snapshot creation
6. **Increased binary size** - Snapshots are typically larger than code cache (+5-10 MB)
7. **Platform-specific** - Snapshots are tied to specific V8 version and platform

**When to use `useSnapshot: true`:**
- ✅ Applications with large dependency trees that are purely computational
- ✅ CLI tools that load many modules but have restricted functionality
- ✅ Applications that can defer dynamic operations until after startup
- ✅ Performance-critical tools where startup time is paramount

**When NOT to use snapshots:**
- ❌ Applications using native addons (e.g., database drivers, crypto libraries)
- ❌ Applications with dynamic code generation or `eval()`
- ❌ Applications that need environment variables or config files at startup
- ❌ Most real-world applications with external dependencies

**Example configuration:**

```json
{
  "main": "app.js",
  "output": "app.blob",
  "disableExperimentalSEAWarning": true,
  "useSnapshot": true,
  "useCodeCache": false
}
```

**Note:** You typically use **either** `useSnapshot` **or** `useCodeCache`, not both. Snapshots provide better startup performance but with significant restrictions.

**Recommendation:** Start with `useCodeCache: true` (safer, works for most apps). Only explore `useSnapshot: true` if you need maximum startup performance and can work within the restrictions.

### Additional Startup Optimizations

**1. Bundle your application** (10-20% faster startup)

Using a bundler like [Rolldown](https://rolldown.rs/) or [esbuild](https://esbuild.github.io/) to create a single CommonJS file significantly reduces module resolution overhead:

```bash
# Using Rolldown
npx rolldown --input src/index.js --output dist/bundle.cjs --format cjs

# Using esbuild
npx esbuild src/index.js --bundle --platform=node --outfile=dist/bundle.cjs

# Then create SEA with the bundle
echo '{"main": "bundle.cjs", "output": "app.blob", "useCodeCache": true}' > sea-config.json
binject inject -e ./node-smol -o ./my-app --sea sea-config.json
```

**Benefits:**
- Eliminates module resolution overhead
- Reduces VFS lookups (if using VFS)
- Tree-shaking removes unused code
- Single file = faster loading

**2. Lazy-load non-critical modules**

Defer imports of modules not needed during startup:

```javascript
// Instead of:
const heavy = require('heavy-module')

function doSomething() {
  heavy.process()
}

// Use lazy loading:
let heavy
function doSomething() {
  if (!heavy) heavy = require('heavy-module')
  heavy.process()
}
```

**3. Minimize dependencies**

Each additional dependency adds startup overhead. Audit your dependencies:

```bash
npx depcheck  # Find unused dependencies
npx bundle-phobia <package>  # Check dependency size impact
```

### Benchmarking Startup Performance

To measure and validate startup improvements, use the included benchmark script:

```bash
# Benchmark a single binary
node scripts/benchmark-startup.mjs ./my-app

# Compare multiple binaries
node scripts/benchmark-startup.mjs ./app-with-cache ./app-no-cache --runs 50

# With warmup runs
node scripts/benchmark-startup.mjs ./my-app --warmup 3 --runs 100
```

**Requirements:** [hyperfine](https://github.com/sharkdp/hyperfine) (install via `brew install hyperfine` on macOS)

**Output:** Creates `benchmark-results.md` and `benchmark-results.json` with detailed timing statistics.

### Runtime Startup Flags

Additional Node.js flags that can improve startup time:

```bash
# Disable all warnings (saves ~1-2ms)
./my-app --no-warnings

# Disable deprecation warnings
./my-app --no-deprecation

# Disable experimental warnings (if using experimental features)
./my-app --no-experimental-warnings
```

**Note:** These flags are already baked into the binary if you set `disableExperimentalSEAWarning: true` in your SEA config.

### Environment Variables

Certain environment variables can impact startup performance:

```bash
# Disable V8 code cache (not recommended - slows startup)
# Only use for debugging code cache issues
NODE_DISABLE_COMPILE_CACHE=1 ./my-app

# Skip update checks (when using update checking feature)
# Saves ~50-100ms on startup
SKIP_UPDATE_CHECK=1 ./my-app
```

**Summary of Startup Optimizations:**

| Optimization | Impact | Trade-off | Recommendation |
|---|---|---|---|
| `useSnapshot: true` | 20-40% faster | +5-10 MB, major restrictions | Only for pure compute apps |
| `useCodeCache: true` | ~13% faster (~22ms) | +2-3 MB binary size | ✅ **Recommended default** |
| Bundle with Rolldown/esbuild | 10-20% faster | Build complexity | ✅ Highly recommended |
| Lazy-load modules | 5-10% faster | Code complexity | If applicable |
| Bootstrap caching (built-in) | ~1-2ms faster | None | ✅ Already enabled |
| `--no-warnings` flag | ~1-2ms faster | May miss warnings | If needed |
| **Total realistic** | **~30-45% faster** | **Varies** | useCodeCache + bundling |
| **Total maximum** | **~60-80% faster** | **High restrictions** | + snapshots (if viable) |

**Approaching Bun's performance:**
- Bun SEA startup: ~90ms
- Node.js SEA baseline: ~161ms (no optimizations)
- With `useCodeCache` + bundling: ~105-120ms (**competitive with Bun**)
- With `useSnapshot` (if viable): ~80-100ms (**matching or beating Bun**)

**Future optimization opportunities (minor gains, <5ms each):**
- Pre-compute TAR index structure at build time (eliminates runtime parsing)
- Move VFS TAR parser from JavaScript to C++ with SIMD optimizations
- Optimize module resolution path caching in bootstrap
- Pre-load core Node.js built-ins into snapshot
- Use V8 compile hints for frequently-executed bootstrap code

These are lower priority compared to the major wins above (code caching, bundling, snapshots).

## Update Checking

Self-extracting binaries include built-in update checking that can be configured at build time.

### Configuration

Update checking is configured when building binaries using binject's `--sea` flag with a sea-config.json file containing a `smol.update` section. See the [SEA Config Integration documentation](../binject/sea-config-integration.md#field-descriptions) for configuration details (look for the nested `update` field under `smol`).

**Runtime behavior:**
- Updates skip automatically in CI environments or non-TTY contexts
- Can be disabled via environment variable (configured in `skip_env` field)
- Checks for updates on configurable intervals (default: 24 hours)

### Notification Display

The notification uses `binname` and `command` from the embedded config:

**Default config** (`binname: ""`, `command: "self-update"`):
```
┌─────────────────────────────────────────┐
│  Update available: 1.0.0 → 1.1.0        │
│  Run: self-update                       │
└─────────────────────────────────────────┘
```

**With binname** (`binname: "myapp"`, `command: "self-update"`):
```
┌─────────────────────────────────────────┐
│  Update available: 1.0.0 → 1.1.0        │
│  Run: myapp self-update                 │
└─────────────────────────────────────────┘
```

**Custom command** (`binname: "myapp"`, `command: "upgrade --latest"`):
```
┌─────────────────────────────────────────┐
│  Update available: 1.0.0 → 1.1.0        │
│  Run: myapp upgrade --latest            │
└─────────────────────────────────────────┘
```

When the user accepts the prompt, the stub executes `<binary_path> <command>` to trigger the update (e.g., `./myapp self-update`). Multiple arguments are supported.

**Interactive prompt** (`prompt: true`, `prompt_default: "y"`):
```
┌─────────────────────────────────────────┐
│  Update available: 1.0.0 → 1.1.0        │
│  Run: myapp self-update                 │
└─────────────────────────────────────────┘
Update to 1.1.0? [Y/n] _
```

## Checkpoint System

This package uses incremental checkpoints to speed up builds and CI:

1. **source-copied** - Node.js source downloaded and extracted
2. **source-patched** - 15 Socket security patches applied
3. **binary-released** - Source compiled to binary
4. **binary-stripped** - Debug symbols removed
5. **binary-compressed** - Binary compressed with binpress
6. **finalized** - Final binary ready for distribution

Checkpoints are cached and restored automatically in CI. See `packages/build-infra` for checkpoint implementation details.

## Patches

Socket applies **15 security and size-optimization patches** to Node.js v25.x:
- Security hardening (GCC LTO fixes, ARM64 branch protection)
- Build system fixes (Python 3 compatibility)
- ICU polyfills for small-icu builds
- VFS integration and bootstrap
- Platform-specific fixes (V8 TypeIndex on macOS)

## License

MIT
