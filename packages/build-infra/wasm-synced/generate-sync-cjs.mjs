/**
 * Generate CommonJS synchronous WASM wrapper.
 *
 * Transforms ESM async WASM module to CommonJS sync wrapper with:
 * - import.meta.url â†’ require("node:url").pathToFileURL(__filename).href
 * - __filename and __dirname for path operations
 * - 'use strict' directive
 * - module.exports for CommonJS compatibility
 */

import fs from 'node:fs/promises'
import path from 'node:path'

import { Parser } from 'acorn'
import { simple as walkSimple } from 'acorn-walk'

import { applyCommonTransforms } from './transform.mjs'

/**
 * Generate CommonJS synchronous wrapper.
 *
 * @param {object} options - Configuration options
 * @param {string} options.mjsContent - MJS glue code content
 * @param {string} options.base64Wasm - Base64-encoded WASM binary
 * @param {Uint8Array} options.wasmBinary - WASM binary
 * @param {string} options.mjsFile - Path to input MJS file
 * @param {string} options.outputSyncJs - Path to output sync.js file
 * @param {string} options.packageName - Package name
 * @param {string} options.initFunctionName - Init function name
 * @param {string} options.exportName - Export name
 * @param {string} [options.description] - Optional description
 * @param {object} options.logger - Logger instance
 * @returns {Promise<string>} Path to generated file
 */
export async function generateSyncCjs(options) {
  const {
    base64Wasm,
    description,
    exportName,
    initFunctionName,
    logger,
    mjsContent: inputMjsContent,
    mjsFile,
    outputSyncJs,
    packageName,
    wasmBinary,
  } = options

  let mjsContent = inputMjsContent

  // === PASS 1: Replace import.meta.url with __importMetaUrl (CJS-specific) ===
  const ast = Parser.parse(mjsContent, {
    ecmaVersion: 'latest',
    sourceType: 'module',
  })

  walkSimple(ast, {
    MetaProperty(node) {
      if (node.meta?.name === 'import' && node.property?.name === 'meta') {
        // This is import.meta - check if it's part of import.meta.url
        // We need to look at the parent context, but acorn-walk doesn't provide parent
        // So we'll use a regex approach instead after initial parse
      }
    },
  })

  // Use regex to replace import.meta.url with __importMetaUrl
  // This is safe because we've already parsed and know the code is valid
  mjsContent = mjsContent.replace(/import\.meta\.url/g, '__importMetaUrl')

  // === PASS 2 & 3: Apply common transformations ===
  mjsContent = await applyCommonTransforms({
    exportName,
    initFunctionName,
    logger,
    mjsContent,
  })

  // Build description line
  const descLine = description
    ? ` * ${description}`
    : ' * Built for synchronous instantiation.'

  // Get file size for documentation
  const mjsStats = await fs.stat(mjsFile)

  // Generate the CommonJS wrapper
  const jsContent = `'use strict';

/**
 * Synchronous ${packageName} with embedded WASM binary.
 *
 * This file is AUTO-GENERATED by ${packageName}-builder.
${descLine}
 *
 * Source: ${path.basename(mjsFile)} (${mjsStats.size} bytes)
 * WASM: ${wasmBinary.length} bytes (${base64Wasm.length} bytes base64)
 */

// Polyfill for import.meta.url in CommonJS (converted from ESM).
// Uses pathToFileURL for proper cross-platform file:// URL conversion.
const __importMetaUrl = require('node:url').pathToFileURL(__filename).href;

// Base64-encoded WASM binary (embedded at build time).
const base64Wasm = '${base64Wasm}';

// Decode base64 to Uint8Array.
const wasmBinary = Uint8Array.from(atob(base64Wasm), c => c.charCodeAt(0));

// Inlined Emscripten loader from ${packageName} build.
${mjsContent}

// Initialize ${packageName} with embedded WASM.
// Pass wasmBinary directly - Emscripten will use instantiateSync for synchronous loading.
const ${exportName}Promise = ${initFunctionName}({
  wasmBinary
});

// CommonJS export - export the promise
// Users must await this: const ${exportName} = await require('./${exportName}-sync.js');
module.exports = ${exportName}Promise;
`

  await fs.writeFile(outputSyncJs, jsContent, 'utf-8')

  const syncJsSize = (await fs.stat(outputSyncJs)).size
  logger.substep(`Sync JS (CJS): ${outputSyncJs}`)
  logger.substep(`Sync JS size: ${(syncJsSize / 1024).toFixed(2)} KB`)

  return outputSyncJs
}
