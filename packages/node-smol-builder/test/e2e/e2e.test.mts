/**
 * @fileoverview End-to-end tests for complete build pipeline.
 *
 * Tests the entire flow:
 * 1. Build node-smol binary (all checkpoints)
 * 2. Create SEA application with VFS
 * 3. Inject dual resources (SEA + VFS)
 * 4. Execute and verify functionality
 * 5. Test VFS extraction to ~/.socket/_dlx/
 * 6. Verify compressed binary decompression
 *
 * Note: These are expensive tests that build the entire binary.
 * Run with: pnpm test:e2e
 */

import { existsSync, promises as fs } from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import { describe, expect, it, beforeAll, afterAll } from 'vitest'

import { safeDelete } from '@socketsecurity/lib/fs'
import { spawn } from '@socketsecurity/lib/spawn'

import { MACHO_SEGMENT_NODE_SEA } from '../../../bin-infra/test/helpers/segment-names.mjs'
import { runBinject, SMOL_VFS_BLOB } from '../helpers/binject.mjs'
import { getLatestFinalBinary, getPackageDir } from '../paths.mjs'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Get the latest Final binary from build/{dev,prod}/out/Final/node/
// This is the production binary suitable for injection and execution
const finalBinaryPath = getLatestFinalBinary()
const packageDir = getPackageDir()
const testTmpDir = path.join(os.tmpdir(), 'socket-btm-e2e-tests')
const _DLX_DIR = path.join(os.homedir(), '.socket', '_dlx')

// Skip all tests if no final binary is available
const skipTests = !finalBinaryPath || !existsSync(finalBinaryPath)

describe.skipIf(skipTests)('End-to-end: Complete build pipeline', () => {
  beforeAll(async () => {
    await fs.mkdir(testTmpDir, { recursive: true })
  })

  afterAll(async () => {
    await safeDelete(testTmpDir)
  })

  describe('Hello World: SEA-only application', () => {
    it(
      'should create and execute simple SEA hello world',
      { timeout: 30_000 },
      async () => {
        const testDir = path.join(testTmpDir, 'hello-sea')
        await fs.mkdir(testDir, { recursive: true })

        // Create simple hello world app
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `#!/usr/bin/env node
console.log('Hello from SEA!');
console.log('Node version:', process.version);
console.log('Platform:', process.platform);
console.log('Architecture:', process.arch);
console.log('Is SEA:', require('node:sea').isSea());
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // SEA blob will be generated by binject from sea-config.json

        // Copy binary and inject SEA
        const appBinary = path.join(testDir, 'hello-sea')
        await fs.copyFile(finalBinaryPath, appBinary)
        await fs.chmod(appBinary, 0o755)

        const injectResult = await runBinject(
          appBinary,
          'NODE_SEA_BLOB',
          'sea-config.json',
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(injectResult.code).toBe(0)

        // Execute and verify
        const execResult = await spawn(appBinary, [], {
          cwd: testDir,
          timeout: 10_000,
        })

        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('Hello from SEA!')
        expect(execResult.stdout).toContain('Is SEA: true')
      },
    )
  })

  describe('Hello World: SEA + VFS application', () => {
    it(
      'should create and execute SEA with VFS hello world',
      { timeout: 30_000 },
      async () => {
        const testDir = path.join(testTmpDir, 'hello-sea-vfs')
        await fs.mkdir(testDir, { recursive: true })

        // Create app that uses VFS
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `#!/usr/bin/env node
console.log('Hello from SEA with VFS!');

// Check if VFS is available
const hasVFS = typeof process._vfs !== 'undefined';
console.log('VFS available:', hasVFS);

if (hasVFS) {
  console.log('VFS files:', Object.keys(process._vfs).length);

  // Try to read package.json from VFS
  try {
    const fs = require('fs');
    const pkg = JSON.parse(fs.readFileSync('/vfs/package.json', 'utf8'));
    console.log('Package name:', pkg.name);
    console.log('Package version:', pkg.version);
  } catch (err) {
    console.error('Failed to read VFS:', err.message);
  }
}

console.log('Is SEA:', require('node:sea').isSea());
`,
        )

        // Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
          }),
        )

        // SEA blob will be generated by binject from sea-config.json

        // Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await fs.mkdir(vfsDir, { recursive: true })
        await fs.writeFile(
          path.join(vfsDir, 'package.json'),
          JSON.stringify({
            name: 'hello-vfs-app',
            version: '1.0.0',
            description: 'Hello World with VFS',
          }),
        )
        await fs.writeFile(
          path.join(vfsDir, 'README.md'),
          '# Hello VFS\n\nThis file is in the VFS!',
        )

        // Create VFS tar.gz
        const vfsTarGz = path.join(testDir, 'vfs.tar.gz')
        const tarResult = await spawn(
          'tar',
          ['czf', vfsTarGz, '-C', vfsDir, '.'],
          { cwd: testDir },
        )
        expect(tarResult.code).toBe(0)

        // Copy binary and inject both SEA and VFS
        const appBinary = path.join(testDir, 'hello-sea-vfs')
        await fs.copyFile(finalBinaryPath, appBinary)
        await fs.chmod(appBinary, 0o755)

        // Inject both SEA and VFS in a single operation
        const injectResult = await runBinject(
          appBinary,
          'BOTH',
          { sea: 'sea-config.json', vfs: vfsTarGz },
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(injectResult.code).toBe(0)

        // Execute and verify
        const execResult = await spawn(appBinary, [], {
          cwd: testDir,
          timeout: 10_000,
        })

        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('Hello from SEA with VFS!')
        expect(execResult.stdout).toContain('VFS available: true')
        expect(execResult.stdout).toContain('Package name: hello-vfs-app')
        expect(execResult.stdout).toContain('Package version: 1.0.0')
        expect(execResult.stdout).toContain('Is SEA: true')
      },
    )
  })

  describe('SEA application build', () => {
    it(
      'should create and execute SEA application',
      { timeout: 30_000 },
      async () => {
        const testDir = path.join(testTmpDir, 'sea-app')
        await fs.mkdir(testDir, { recursive: true })

        // Step 1: Create simple SEA application
        // NOTE: Stripped binary doesn't have VFS support (no C++ binding, no JS modules)
        // VFS functionality is tested separately in vfs.test.mjs
        const appJs = path.join(testDir, 'app.js')
        await fs.writeFile(
          appJs,
          `
console.log('=== SEA Application ===');
console.log('Node version:', process.version);

// Check if running as SEA
const isSEA = require('node:sea').isSea();
console.log('Running as SEA:', isSEA);

if (isSEA) {
  console.log('✓ SEA execution successful');
  process.exit(0);
} else {
  console.error('✗ Not running as SEA');
  process.exit(1);
}
`,
        )

        // Step 2: Create SEA config
        const seaConfig = path.join(testDir, 'sea-config.json')
        await fs.writeFile(
          seaConfig,
          JSON.stringify({
            main: 'app.js',
            output: 'app.blob',
            disableExperimentalSEAWarning: true,
            useCodeCache: true,
          }),
        )

        // Step 3: SEA blob will be generated by binject from sea-config.json
        console.log('SEA blob will be generated by binject...')

        // Step 4: Create VFS content
        const vfsDir = path.join(testDir, 'vfs-content')
        await fs.mkdir(vfsDir, { recursive: true })

        // Create sample application files
        await fs.writeFile(
          path.join(vfsDir, 'package.json'),
          JSON.stringify({ name: 'test-app', version: '1.0.0' }),
        )
        await fs.writeFile(path.join(vfsDir, 'README.md'), '# Test Application')

        // Create subdirectories
        await fs.mkdir(path.join(vfsDir, 'lib'), { recursive: true })
        await fs.writeFile(
          path.join(vfsDir, 'lib', 'utils.js'),
          'module.exports = { version: "1.0.0" };',
        )

        await fs.mkdir(path.join(vfsDir, 'assets'), { recursive: true })
        await fs.writeFile(
          path.join(vfsDir, 'assets', 'data.json'),
          '{"test":true}',
        )

        // Step 5: Create VFS TAR.GZ (compressed for smaller size)
        const vfsTarGz = path.join(testDir, 'vfs.tar.gz')
        console.log('Creating VFS archive...')
        const tarResult = await spawn(
          'tar',
          ['czf', vfsTarGz, '-C', vfsDir, '.'],
          { cwd: testDir },
        )
        expect(tarResult.code).toBe(0)
        expect(existsSync(vfsTarGz)).toBe(true)

        // Step 6: Copy node-smol binary
        const appBinary = path.join(testDir, 'myapp')
        await fs.copyFile(finalBinaryPath, appBinary)
        await fs.chmod(appBinary, 0o755)

        // Step 7: Inject SEA blob
        console.log('Injecting SEA blob...')
        const injectSeaResult = await runBinject(
          appBinary,
          'NODE_SEA_BLOB',
          'sea-config.json',
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: MACHO_SEGMENT_NODE_SEA,
          },
        )
        expect(injectSeaResult.code).toBe(0)

        // Step 8: Inject VFS blob
        console.log('Injecting VFS blob...')
        const injectVfsResult = await runBinject(
          appBinary,
          SMOL_VFS_BLOB,
          vfsTarGz,
          {
            testDir,
            sentinelFuse: 'NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2',
            machoSegmentName: 'NODE_VFS',
          },
        )
        expect(injectVfsResult.code).toBe(0)

        // Step 9: Execute application
        console.log('Executing application...')
        const execResult = await spawn(appBinary, [], {
          cwd: testDir,
          timeout: 30_000,
        })

        expect(execResult.code).toBe(0)
        expect(execResult.stdout).toContain('Node-Smol Application')
        expect(execResult.stdout).toContain('Running as SEA: true')
        expect(execResult.stdout).toContain('VFS available: true')
        expect(execResult.stdout).toContain('VFS blob size:')
        expect(execResult.stdout).toContain(
          '✓ Application completed successfully',
        )

        // Verify VFS blob is non-empty
        const blobSizeMatch = execResult.stdout.match(
          /VFS blob size: (\d+) bytes/,
        )
        expect(blobSizeMatch).toBeTruthy()
        const blobSize = Number.parseInt(blobSizeMatch[1], 10)
        expect(blobSize).toBeGreaterThan(0)
      },
    )
  })

  describe('Binary compression integration', () => {
    it('should work with compressed binary if available', async () => {
      const compressedBinary = path.join(
        packageDir,
        'build',
        'out',
        'Compressed',
        'node',
        'node',
      )

      // Only test if compressed binary exists.
      if (!existsSync(compressedBinary)) {
        console.log('Skipping: No compressed binary found')
        return
      }

      // Test basic execution (self-extracting binary).
      const execResult = await spawn(compressedBinary, ['--version'])
      expect(execResult.code).toBe(0)
      expect(execResult.stdout).toMatch(/^v24\.\d+\.\d+/)
    })
  })

  describe('Cross-platform compatibility', () => {
    it('should report correct platform and architecture', async () => {
      const execResult = await spawn(finalBinaryPath, [
        '-p',
        'JSON.stringify({ platform: process.platform, arch: process.arch })',
      ])

      expect(execResult.code).toBe(0)
      const info = JSON.parse(execResult.stdout.trim())
      expect(info.platform).toBe(process.platform)
      expect(info.arch).toBe(process.arch)
    })

    it('should have correct ICU configuration', async () => {
      const execResult = await spawn(finalBinaryPath, [
        '-p',
        'process.config.variables.icu_small',
      ])

      expect(execResult.code).toBe(0)
      // Should be using small-icu (true) for prod builds
      // or undefined/false for dev builds
      const icuSmall = execResult.stdout.trim()
      expect(['true', 'undefined', 'false']).toContain(icuSmall)
    })
  })
})
