name: 'Restore Checkpoint Chain'
description: 'Restores build output from checkpoint tarballs, walking backward to find the latest valid checkpoint'
author: 'Socket Security'

inputs:
  package-name:
    description: 'Package name (e.g., onnxruntime-builder, yoga-layout-builder, models, node-smol-builder)'
    required: true
  build-mode:
    description: 'Build mode (dev or prod)'
    required: true
  checkpoint-chain:
    description: 'Ordered list of checkpoints to try (newest to oldest), comma-separated (e.g., "finalized,wasm-synced,wasm-released,wasm-compiled")'
    required: true
  cache-hit:
    description: 'Whether checkpoint cache was hit (true/false)'
    required: true
  cache-valid:
    description: 'Whether checkpoint cache validation passed (true/false)'
    required: true

outputs:
  restored:
    description: 'Whether any checkpoint was restored (true/false)'
    value: ${{ steps.restore.outputs.restored || steps.skip.outputs.restored }}
  checkpoint-restored:
    description: 'Name of the checkpoint that was restored (empty if none)'
    value: ${{ steps.restore.outputs.checkpoint_restored || steps.skip.outputs.checkpoint_restored }}
  checkpoint-index:
    description: 'Index of restored checkpoint (0=newest, higher=older)'
    value: ${{ steps.restore.outputs.checkpoint_index || steps.skip.outputs.checkpoint_index }}
  build-required:
    description: 'Whether build is required to complete remaining checkpoints (true/false)'
    value: ${{ steps.restore.outputs.build_required || steps.skip.outputs.build_required }}

runs:
  using: 'composite'
  steps:
    - name: Restore build output from checkpoint chain
      id: restore
      if: inputs.cache-hit == 'true' && (inputs.cache-valid == 'true' || inputs.cache-valid == 'partial')
      shell: bash
      run: |
        set -e
        echo "üîÑ Restoring build output from checkpoint chain..."
        echo ""

        PACKAGE_NAME="${{ inputs.package-name }}"
        BUILD_MODE="${{ inputs.build-mode }}"
        CHECKPOINT_CHAIN="${{ inputs.checkpoint-chain }}"

        # Validate inputs to prevent command injection
        # Use [[ =~ ]] instead of echo|grep to prevent newline injection bypass
        if ! [[ "${PACKAGE_NAME}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "‚ùå Invalid package name: ${PACKAGE_NAME}"
          echo "   Package name must contain only alphanumeric characters, hyphens, and underscores"
          exit 1
        fi

        if ! [[ "${BUILD_MODE}" =~ ^(prod|dev)$ ]]; then
          echo "‚ùå Invalid build mode: ${BUILD_MODE}"
          echo "   Build mode must be either 'prod' or 'dev'"
          exit 1
        fi

        # Validate checkpoint chain has no empty segments
        if [[ "${CHECKPOINT_CHAIN}" =~ (^,|,,|,$) ]]; then
          echo "‚ùå Invalid checkpoint chain: contains empty segments"
          exit 1
        fi

        MODE_CHECKPOINT_DIR="packages/${PACKAGE_NAME}/build/${BUILD_MODE}/checkpoints"
        SHARED_CHECKPOINT_DIR="packages/${PACKAGE_NAME}/build/shared/checkpoints"
        OUTPUT_DIR="packages/${PACKAGE_NAME}/build/${BUILD_MODE}/out"
        SHARED_SOURCE_DIR="packages/${PACKAGE_NAME}/build/shared/source"
        MODE_SOURCE_DIR="packages/${PACKAGE_NAME}/build/${BUILD_MODE}/source"

        echo "üì¶ Package: ${PACKAGE_NAME}"
        echo "üîß Build mode: ${BUILD_MODE}"
        echo "üìÅ Mode checkpoint directory: ${MODE_CHECKPOINT_DIR}"
        echo "üìÅ Shared checkpoint directory: ${SHARED_CHECKPOINT_DIR}"
        echo "üì§ Output directory: ${OUTPUT_DIR}"
        echo "üìÇ Shared source directory: ${SHARED_SOURCE_DIR}"
        echo "üìÇ Mode source directory: ${MODE_SOURCE_DIR}"
        echo ""

        # Parse checkpoint chain into array (comma-separated, localize IFS to prevent side effects)
        # Use trap to ensure IFS is restored even if script exits unexpectedly
        restore_ifs() {
          IFS="$OLD_IFS"
        }
        OLD_IFS="$IFS"
        trap restore_ifs EXIT
        IFS=','
        read -ra CHECKPOINTS <<< "$CHECKPOINT_CHAIN"
        IFS="$OLD_IFS"
        trap - EXIT

        echo "üîó Checkpoint chain (newest ‚Üí oldest):"
        INDEX=0
        for CHECKPOINT in "${CHECKPOINTS[@]}"; do
          echo "  [$INDEX] ${CHECKPOINT}"
          INDEX=$((INDEX + 1))
        done
        echo ""

        # Walk backward through checkpoint chain to find latest valid one
        RESTORED_CHECKPOINT=""
        RESTORED_INDEX=-1

        INDEX=0
        for CHECKPOINT in "${CHECKPOINTS[@]}"; do
          # source-cloned is in shared directory, all others are mode-specific
          if [ "${CHECKPOINT}" = "source-cloned" ]; then
            CHECKPOINT_FILE="${SHARED_CHECKPOINT_DIR}/${CHECKPOINT}.tar.gz"
          else
            CHECKPOINT_FILE="${MODE_CHECKPOINT_DIR}/${CHECKPOINT}.tar.gz"
          fi

          echo "üîç Checking checkpoint [$INDEX]: ${CHECKPOINT}"

          # Check if checkpoint exists
          if [ ! -f "${CHECKPOINT_FILE}" ]; then
            echo "   ‚è≠Ô∏è  Not found, trying next..."
            INDEX=$((INDEX + 1))
            continue
          fi

          echo "   ‚úì Found: ${CHECKPOINT_FILE}"

          # Verify tarball integrity
          if ! gzip -t "${CHECKPOINT_FILE}" 2>/dev/null; then
            echo "   ‚ö†Ô∏è  Corrupted, trying next..."
            INDEX=$((INDEX + 1))
            continue
          fi

          echo "   ‚úì Integrity verified"

          # This is our restoration point!
          RESTORED_CHECKPOINT="${CHECKPOINT}"
          RESTORED_INDEX=${INDEX}

          echo ""
          echo "‚úÖ Found valid checkpoint: ${CHECKPOINT} (index ${INDEX})"
          break
        done

        # Check if we found any checkpoint
        if [ -z "${RESTORED_CHECKPOINT}" ]; then
          echo ""
          echo "‚ùå No valid checkpoints found in chain"
          echo "   Available mode checkpoints:"
          find "${MODE_CHECKPOINT_DIR}" -type f -ls 2>/dev/null || echo "   (mode checkpoint directory not found)"
          echo "   Available shared checkpoints:"
          find "${SHARED_CHECKPOINT_DIR}" -type f -ls 2>/dev/null || echo "   (shared checkpoint directory not found)"
          echo ""
          echo "restored=false" >> $GITHUB_OUTPUT
          echo "checkpoint_restored=" >> $GITHUB_OUTPUT
          echo "checkpoint_index=-1" >> $GITHUB_OUTPUT
          echo "build_required=true" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo ""
        echo "üì¶ Restoring from checkpoint: ${RESTORED_CHECKPOINT}"
        echo ""

        # Show tarball contents
        if [ "${RESTORED_CHECKPOINT}" = "source-cloned" ]; then
          CHECKPOINT_FILE="${SHARED_CHECKPOINT_DIR}/${RESTORED_CHECKPOINT}.tar.gz"
        else
          CHECKPOINT_FILE="${MODE_CHECKPOINT_DIR}/${RESTORED_CHECKPOINT}.tar.gz"
        fi
        echo "üìã Checkpoint contents:"
        tar -tzf "${CHECKPOINT_FILE}" | head -20
        TOTAL_FILES=$(tar -tzf "${CHECKPOINT_FILE}" | wc -l | tr -d ' ')
        if [ "${TOTAL_FILES}" -gt 20 ]; then
          echo "... (${TOTAL_FILES} total files)"
        fi
        echo ""

        # Extract checkpoint to correct directory based on checkpoint name
        # Checkpoint structure varies by package:
        #
        # node-smol-builder:
        # - finalized ‚Üí build/{mode}/out/Final/
        # - binary-compressed ‚Üí build/{mode}/out/Compressed/
        # - binary-stripped ‚Üí build/{mode}/out/Stripped/
        # - binary-released ‚Üí build/{mode}/out/Release/
        # - source-cloned ‚Üí build/shared/source/
        # - source-patched ‚Üí build/{mode}/source/
        #
        # onnxruntime-builder, yoga-layout-builder:
        # - finalized ‚Üí build/{mode}/out/Final/
        # - wasm-synced ‚Üí build/{mode}/out/Synced/
        # - wasm-released ‚Üí build/{mode}/out/Released/
        # - wasm-optimized ‚Üí build/{mode}/out/Optimized/
        # - wasm-compiled ‚Üí build/{mode}/out/Compiled/
        # - source-configured ‚Üí build/{mode}/source/ (yoga-layout only)
        # - source-cloned ‚Üí build/shared/source/
        #
        # binpress, binflate, binject:
        # - finalized ‚Üí build/{mode}/out/ (single-phase build, no subdirectory)
        # - lief-built ‚Üí build/lief/ (LIEF library build, shared across modes, binject only)
        #
        # models:
        # - finalized ‚Üí build/{mode}/out/Final/
        # - quantized ‚Üí build/{mode}/models/
        # - converted ‚Üí build/{mode}/models/
        # - downloaded ‚Üí build/{mode}/models/
        EXTRACT_DIR="${OUTPUT_DIR}"
        case "${RESTORED_CHECKPOINT}" in
          finalized)
            # Single-phase build tools (binpress, binflate, binject) extract directly to out/
            # Multi-phase builders (node-smol-builder, onnxruntime-builder, etc.) extract to out/Final/
            if [ "${PACKAGE_NAME}" = "binpress" ] || [ "${PACKAGE_NAME}" = "binflate" ] || [ "${PACKAGE_NAME}" = "binject" ]; then
              EXTRACT_DIR="${OUTPUT_DIR}"
            else
              EXTRACT_DIR="${OUTPUT_DIR}/Final"
            fi
            ;;
          # binject LIEF build checkpoint
          lief-built)
            # LIEF checkpoint: extract to shared lief directory (not mode-specific)
            EXTRACT_DIR="packages/${PACKAGE_NAME}/build/lief"
            ;;
          # node-smol-builder checkpoints
          binary-compressed)
            EXTRACT_DIR="${OUTPUT_DIR}/Compressed"
            ;;
          binary-stripped)
            EXTRACT_DIR="${OUTPUT_DIR}/Stripped"
            ;;
          binary-released)
            EXTRACT_DIR="${OUTPUT_DIR}/Release"
            ;;
          # onnxruntime-builder, yoga-layout-builder checkpoints
          wasm-synced)
            EXTRACT_DIR="${OUTPUT_DIR}/Synced"
            ;;
          wasm-released)
            EXTRACT_DIR="${OUTPUT_DIR}/Released"
            ;;
          wasm-optimized)
            EXTRACT_DIR="${OUTPUT_DIR}/Optimized"
            ;;
          wasm-compiled)
            EXTRACT_DIR="${OUTPUT_DIR}/Compiled"
            ;;
          source-configured)
            # yoga-layout-builder specific: extract to mode source directory
            EXTRACT_DIR="${MODE_SOURCE_DIR}"
            ;;
          # models checkpoints
          quantized|converted|downloaded)
            # Models checkpoints extract to build/{mode}/models/
            EXTRACT_DIR="packages/${PACKAGE_NAME}/build/${BUILD_MODE}/models"
            ;;
          # Source checkpoints (shared across packages)
          source-cloned)
            # Shared checkpoint: extract to shared source directory
            EXTRACT_DIR="${SHARED_SOURCE_DIR}"
            ;;
          source-patched)
            # Mode-specific checkpoint: extract to mode source directory
            EXTRACT_DIR="${MODE_SOURCE_DIR}"
            ;;
        esac

        echo "üì¶ Extracting checkpoint to ${EXTRACT_DIR}..."
        mkdir -p "${EXTRACT_DIR}"

        # Validate tarball size before extraction (protect against zip bombs)
        COMPRESSED_SIZE=$(stat -c%s "${CHECKPOINT_FILE}" 2>/dev/null || stat -f%z "${CHECKPOINT_FILE}")
        MAX_COMPRESSED=$((10 * 1024 * 1024 * 1024))  # 10GB compressed limit

        if [ "${COMPRESSED_SIZE}" -gt "${MAX_COMPRESSED}" ]; then
          echo "‚ùå Checkpoint tarball too large: ${COMPRESSED_SIZE} bytes (max: ${MAX_COMPRESSED})"
          echo "   This may indicate a corrupted or malicious tarball"
          exit 1
        fi

        echo "   Tarball size: $((COMPRESSED_SIZE / 1024 / 1024))MB"

        # Extract tarball, stripping the top-level directory wrapper
        # --strip-components=1: remove first directory level from paths
        # Example: tarball contains Final/ort.wasm ‚Üí extracts to out/Final/ort.wasm
        # All checkpoints create directory archives for consistency
        if ! tar -xzf "${CHECKPOINT_FILE}" -C "${EXTRACT_DIR}" --strip-components=1; then
          echo "‚ùå Failed to extract checkpoint: ${CHECKPOINT_FILE}"
          echo "   This may indicate disk space issues, permissions problems, or tarball corruption"
          exit 1
        fi

        # Verify extraction produced files
        if [ -z "$(ls -A "${EXTRACT_DIR}" 2>/dev/null)" ]; then
          echo "‚ùå Extraction produced no files in ${EXTRACT_DIR}"
          echo "   Tarball may be empty or extraction path may be incorrect"
          exit 1
        fi

        echo "‚úÖ Checkpoint extracted successfully"
        echo ""

        # Verify checkpoint metadata JSON exists (needed for shouldRun() detection)
        # The JSON file lives alongside the tarball and is restored by the cache action
        CHECKPOINT_JSON="${CHECKPOINT_FILE%.tar.gz}.json"
        if [ -f "${CHECKPOINT_JSON}" ]; then
          echo "üìù Checkpoint metadata verified"
          echo "   ‚úì ${CHECKPOINT_JSON}"
          echo "   Build scripts will detect this checkpoint via shouldRun()"
        else
          echo "‚ö†Ô∏è  Warning: Checkpoint metadata missing: ${CHECKPOINT_JSON}"
          echo "   Build may not skip completed phases properly"
        fi
        echo ""

        # Determine if build needs to run
        NEEDS_BUILD="false"
        if [ ${RESTORED_INDEX} -gt 0 ]; then
          NEEDS_BUILD="true"
          echo "‚öôÔ∏è  Build will run to complete remaining checkpoints:"
          REMAINING_INDEX=0
          for CHECKPOINT in "${CHECKPOINTS[@]}"; do
            if [ ${REMAINING_INDEX} -lt ${RESTORED_INDEX} ]; then
              echo "   ‚Ä¢ ${CHECKPOINT} (will be created)"
            fi
            REMAINING_INDEX=$((REMAINING_INDEX + 1))
          done
        else
          echo "‚úÖ Latest checkpoint restored - build can be skipped"
        fi
        echo ""

        # Check what was extracted
        if [ -d "${OUTPUT_DIR}" ]; then
          echo "üìÅ Extracted output:"
          find "${OUTPUT_DIR}" -type f | head -20
          FILES_COUNT=$(find "${OUTPUT_DIR}" -type f | wc -l | tr -d ' ')
          if [ "${FILES_COUNT}" -gt 20 ]; then
            echo "... (${FILES_COUNT} total files)"
          fi
          echo ""
        fi

        echo "‚úÖ Restoration complete"
        echo "   Checkpoint: ${RESTORED_CHECKPOINT}"
        echo "   Index: ${RESTORED_INDEX} (0=newest, ${#CHECKPOINTS[@]}-1=oldest)"
        echo "   Needs build: ${NEEDS_BUILD}"
        echo ""

        echo "restored=true" >> $GITHUB_OUTPUT
        echo "checkpoint_restored=${RESTORED_CHECKPOINT}" >> $GITHUB_OUTPUT
        echo "checkpoint_index=${RESTORED_INDEX}" >> $GITHUB_OUTPUT
        echo "build_required=${NEEDS_BUILD}" >> $GITHUB_OUTPUT

    - name: Skip restoration (build will run from scratch)
      id: skip
      if: inputs.cache-hit != 'true' || (inputs.cache-valid != 'true' && inputs.cache-valid != 'partial')
      shell: bash
      run: |
        echo "‚è≠Ô∏è  Skipping checkpoint restoration (build will run from scratch)"
        echo "   Cache hit: ${{ inputs.cache-hit }}"
        echo "   Cache valid: ${{ inputs.cache-valid }}"
        echo ""
        echo "restored=false" >> $GITHUB_OUTPUT
        echo "checkpoint_restored=" >> $GITHUB_OUTPUT
        echo "checkpoint_index=-1" >> $GITHUB_OUTPUT
        echo "build_required=true" >> $GITHUB_OUTPUT
